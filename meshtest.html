<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"/></head>
<body>
<script src="maparray.js"></script>
<script src="alteration.js"></script>
<script src="construction.js"></script>
<script src="evaluation.js"></script>
<script src="generator2d.js"></script>
<script src="generator3d.js"></script>
<script src="help.js"></script>
<script src="lzstring.js"></script>
<script src="matrix.js"></script>
<script src="meta.js"></script>
<script src="parsenumber.js"></script>
<script src="parseword.js"></script>
<script src="pixel.js"></script>
<script src="polygon.js"></script>
<script src="polyhedron.js"></script>
<script src="statement.js"></script>
<script src="voxel.js"></script>
<script>
//License = GNU Affero General Public License http://www.gnu.org/licenses/agpl.html

const gPlanarColors = [[0,255,0], [0,255,0], [0,0,255], [0,0,255], [255,0,0], [255,0,0]]
// upload
// try to eliminate openingStatement
// triangulating identical points bug, check triangle speed
// scalePoly(x, and y) in transform2Ds instead of extraTransform2Ds
// multiply or mirror polygons, polylines and construction
// Polyline.forEachY(symbol, array, array or scalar)
// parabola
// alphabetic encoding and compression
// close to line in sculpture
// use warningList instead of warning
// spring or staple or hook or fastener
// extrusion and sculpture by equations, transforms
// 2d construction
// delete getIntervalsIncludingEnd
// check view problem in donut
// bend __amplitudes=0,1 analysis=t basis2D=1,0 boundaryEquations=testBoundary center=2,2
// translationEquations=testTranslation work=donut {
// __rectangle points=-2 10
// string testBoundary=point[2] > 7.0 testTranslation=[point[0], 0.0, 0.0]
// }
// check polygonAnalysis when there is are lone edges in brick around top wedge
// connect facets on point line in construction
// make viewer bigger with outside rotation handles
// deprecate all non 3d tags in links
//
// getShapeGenerator, change objectMap to meshGeneratorMap, update changed text in transforms
// check linkMap in getMeshAnalysis, count empty intersection pairs
// add warning for missing work and other missing and getStatementID whileIndex
// operate and transform polygons in wordscape, maybe use true location instead of inverse for points in drillMesh
// deprecate exclusiveIntersection
// better colors
// add nodes between exteriors to polygons, add node within new triangle
// triangulate coplanar for output, make basic shapes, combine loops from multiple meshes
// check for line intersection between polygons
// check for and join polylines in getXYPolygonsMap when there are missing faces
// check for intersection pairs between exteriors
// check for unplanar polygons and triangulate
// check for z at node level when converting to xy
// getDirectedPolygon3D using vertex z if available
// solids = [], solid = {meshes:[{name:, points:[], facets:[], matrix:4x4}], construction:"..", name, color, material}
// construction -> + union, - difference, * intersection
// getTriangularMesh, getPolyhedralMesh, getCarving, getStatement, get JSON
// shape isLatticed, isPillar, mesh or pillar
// else statement could check for previousStatement then set all the previousStatement of the siblings

function drawLines(lines, pointMap) {
	for (var line of lines) {
		drawXYZPolyline([pointMap.get(line.beginKey), pointMap.get(line.endKey)], gPlanarColors[line.crossDirectionIndex])
//	document.writeln('<line x1="' + x1 + '" y1="' + y1 + '" x2="' + x2 + '" y2="' + y2 + '"  style="fill:none;stroke:' + line.color + ';" />')
//	document.writeln('<line x1="' + x1 + '" y1="' + y1 + '" x2="' + x2 + '" y2="' + y2 + '"  style="fill:none;stroke:' + line.color + ';" marker-end="url(#arrowhead)" />')
	}
}

function drawMesh(mesh) {
	var index = 0
	var points = mesh.points
	var z = 0.0
	for (var facet of mesh.facets) {
		var polygon = new Array(facet.length)
		for (var keyIndex = 0; keyIndex < polygon.length; keyIndex++) {
			polygon[keyIndex] = points[facet[keyIndex]]
			polygon[keyIndex] = getXYZAddition(polygon[keyIndex], [0.03 * (index % 3), 0.02 * (index % 5), 0.014 * (index % 7)])
			z = polygon[keyIndex][2]
		}
		drawXYZPolygon(polygon, getRGB())
		index = Math.round(z)
//		drawXYZPolygon(polygon, getRGBByIndex(index))
	}
}

function drawPixelMap(pixelMap) {
	for (var entry of pixelMap) {
		var key = entry[0]
		var value = entry[1]
		var parameters = key.split(',')
		var cx = parseFloat(parameters[0])
		var cy = parseFloat(parameters[1])
		document.writeln('<circle cx="' + cx + '" cy="' + cy + '" r="0.15" />')
		for (directionIndex = 0; directionIndex < gXYDirections.length; directionIndex++) {
			var xy = value[directionIndex]
			if (xy != null) {
				var direction = gXYDirections[directionIndex]
				document.writeln('<circle cx="' + xy[0] + '" cy="' + xy[1] + '" r="0.04" />')
				var cxTip = cx + 0.15 * direction[0]
				var cyTip = cy + 0.15 * direction[1]
				document.writeln('<circle cx="' + cxTip + '" cy="' + cyTip + '" r="0.02" />')
			}
		}
	}
}

function drawVoxelMap(voxelMap) {
	for (var entry of voxelMap) {
		var value = entry[1]
		var parameters = entry[0].split(',').slice(0).map(parseFloat)
		var center = getXYPointStringByXYZ(parameters).split(',')
		var rgbString = '" style="stroke:rgb(' + getRGBByIndex(Math.round(parameters[2])).join(',') + ')" />'
		document.writeln('<circle cx="' + center[0] + '" cy="' + center[1] + '" r="0.3' + rgbString)
		for (directionIndex = 0; directionIndex < gDirections.length; directionIndex++) {
			xyz = value[directionIndex]
			if (xyz != null) {
				direction = gDirections[directionIndex]
				var cTip = getXYPointStringByXYZ(xyz).split(',')
				document.writeln('<circle cx="' + cTip[0] + '" cy="' + cTip[1] + '" r="0.08' + rgbString)
				var cDirection = getXYPointStringByXYZ(addXYZ(getXYZMultiplicationByScalar(direction, 0.3), parameters)).split(',')
				document.writeln('<circle cx="' + cDirection[0] + '" cy="' + cDirection[1] + '" r="0.04' + rgbString)
			}
		}
	}
}

function drawXYLines(lines, pointMap) {
	for (var line of lines) {
		var pointStrings = [pointMap.get(line.beginKey).join(','), pointMap.get(line.endKey).join(',')]
		document.writeln('<polyline  points="' + pointStrings.join(' ') + '" style="stroke:rgb(' + gPlanarColors[0].join(',') + ')" />')
	}
}

function drawXYPolygon(xyPolygon, rgb) {
	var pointStrings = new Array(xyPolygon.length)
	for (var pointIndex = 0; pointIndex < xyPolygon.length; pointIndex++) {
		if (xyPolygon[pointIndex].length < 3) {
			pointStrings[pointIndex] = xyPolygon[pointIndex].join(',')
		}
		else {
			pointStrings[pointIndex] = xyPolygon[pointIndex].slice(0, 2).join(',')
		}
	}
	document.writeln('<polygon  points="' + pointStrings.join(' ') + '" style="stroke:rgb(' + rgb.join(',') + ')" />')
}

function drawXYPolygons(xyPolygons) {
	for (var xyPolygon of xyPolygons) {
		drawXYPolygon(xyPolygon, getRGB())
	}
}

function drawXYPolyline(xyPolyline, rgb) {
	var pointStrings = new Array(xyPolyline.length)
	for (var pointIndex = 0; pointIndex < xyPolyline.length; pointIndex++) {
		if (xyPolyline[pointIndex].length < 3) {
			pointStrings[pointIndex] = xyPolyline[pointIndex].join(',')
		}
		else {
			pointStrings[pointIndex] = xyPolyline[pointIndex].slice(0, 2).join(',')
		}
	}
	document.writeln('<polyline  points="' + pointStrings.join(' ') + '" style="stroke:rgb(' + rgb.join(',') + ')" />')
}

function drawXYPolylines(xyPolylines) {
	for (var xyPolyline of xyPolylines) {
		drawXYPolyline(xyPolyline, getRGB())
	}
}

function drawXYZPoints(points) {
	for (var point of points) {
		var center = getXYPointStringByXYZ(point).split(',')
		document.writeln('<circle cx="' + center[0] + '" cy="' + center[1] + '" r="0.02" />')
	}
}

function drawXYZPolygon(points, rgb) {
	document.writeln('<polygon  points="' + getXYPointStringsByXYZ(points).join(' ') + '" style="stroke:rgb(' + rgb.join(',') + ')" />')
}

function drawXYZPolygons(xyzPolygons) {
	for (var xyzPolygon of xyzPolygons) {
		drawXYZPolygon(xyzPolygon, getRGB())
	}
}

function drawXYZPolygonKeyStrings(xyzPolygonKeyStrings) {
	drawXYZPolygons(convertKeyStringsToPolygons(xyzPolygonKeyStrings))
}

function drawXYZPolyline(points, rgb) {
	document.writeln('<polyline  points="' + getXYPointStringsByXYZ(points).join(' ') + '" style="stroke:rgb(' + rgb.join(',') + ')" />')
}

function getXYPointStringByXYZ(point) {
//	return [point[0], point[1] + point[2] * 0.3].join(',')
	return [point[0] + point[2] * 0.3, point[1] + point[2] * 0.2].join(',')
}

function getXYPointStringsByXYZ(points) {
	var pointStrings = new Array(points.length)
	for (var pointIndex = 0; pointIndex < points.length; pointIndex++) {
		pointStrings[pointIndex] = getXYPointStringByXYZ(points[pointIndex])
	}
	return pointStrings
}

function testBend() {
	console.log('testBend')
//	var pointString = '-2,-2 -2,9 12,-2 0,-1 0,7 10,-1 1,0 1,5 6,0 2,1 4,1 2,3 11,1 13,1 11,3'
	var pointString = '-2,-2,0 -2,6,0 5,-2,0'
//	var pointString = '-2,-2 -2,6 5,-2 4,-2 3,-2 2,-2 1.5,-2 1,-2 0,-2 -1,-2'
	var points = getPointsByString(pointString)
	drawXYPolygon(points, getRGB())
	var boundaryEquation = 'point[0] > 0.0'
	var boundaryPolygons = [[[-3,-3], [-3,2], [8,-3]]]
	var translationEquation = '3.0'
	var variableMap = new Map()
	var parent = {parent:null, variableMap:variableMap}
	var statement = {parent:parent}
	drawXYPolygons(boundaryPolygons)
	var stratas = [[-5,-3]]
	var amplitudes = [[0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 3.0], [4.0, 4.0], [5.0, 5.0, 6.0]]
	var boundedPoints = getBoundedPoints3D([boundaryEquation], null, points, boundaryPolygons, null, statement, stratas)
//	var boundedPoints = getBoundedPoints2D([boundaryEquation], points, boundaryPolygons, null, statement)
//	var boundedPoints = getBoundedPoints2D(null, points, [[[-3,-3], [-3,2], [2,-3]]])
	console.log('boundedPoints')
	console.log(getArraysCopy(boundedPoints))
	console.log(getArraysCopy(points))
	console.log(boundaryPolygons)
//	transformPoints2DByEquation(null, null, null, boundedPoints, null, statement, [translationEquation])
	transformPoints3DByEquation(amplitudes, null, null, boundedPoints, null, statement, [translationEquation])
	console.log(boundedPoints)
	drawXYPolygon(points, getRGB())
	console.log(points)
}

function testConnectedPolygons() {
	var pointString = '-2,-2 -2,9 12,-2 0,-1 0,7 10,-1 1,0 1,5 6,0 2,1 4,1 2,3 11,1 13,1 11,3'
	var facets = []
	var endFacets = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14]]
	var points = getPointsByString(pointString)
	addInsideConnectedFacets(endFacets, facets, points)
	var xyPolygons = getPolygonsByFacets(facets, points)
	drawXYPolygons(xyPolygons)
}

function testDrillByMesh() {
	var pointString = '-2,-2,0 -2,7,0 7,8,0 12,-2,0 10,-1,2 0,7,2 0,-1,2 14,1,6 16,1,6 14,3,6'
//	var pointString = '-2,-2,0 -2,7,0 7,8,0 12,-2,0 0,-1,2 0,7,2 10,-1,2 1,-1,5 1,5,5 7,-1,5 14,1,6 16,1,6 14,3,6'
	var facets = [[0, 1, 2, 3], [4, 5, 6], [7, 8, 9]]
	var points = getPointsByString(pointString)
	var centerPolygon = [[4, 1], [6, 1], [5, 3]]
	var centerMesh = getPillarMesh([centerPolygon], [0.0, 1.0], get3DUnitMatrix())
//	drawMesh(centerMesh)
//	drawXYPolygon(centerPolygon, getRGB())
	drillByMesh(centerMesh, null, get3DUnitMatrix(), {facets:facets, points:points})
	drawXYZPolygons(getPolygonsByFacets(facets, points))
}

function testDrillByPolygon() {
//	var basisXZ = get3DTransformByBasis([1.0, 0.0, 0.0, 0.0, 1.0, 0.0])
	var basisXZ = get3DTransformByBasis([1.0, 0.0, 0.0, 0.0, 0.0, 1.0])
	var pointString = '-2,-2,0 -2,7,0 7,8,0 12,-2,0 10,-1,2 0,7,2 0,-1,2 14,1,6 16,1,6 14,3,6'
//	var pointString = '-2,-2,0 -2,7,0 7,8,0 12,-2,0 0,-1,1 0,7,1 10,-1,1 1,-1,5 1,5,5 7,-1,5 14,1,6 16,1,6 14,3,6'
	var facets = [[0, 1, 2, 3], [4, 5, 6], [7, 8, 9]]
	var points = getPointsByString(pointString)
	points = getXYZsBy3DMatrix(basisXZ, points)
	var centerPolygon = [[2, 1], [4, 1], [3, 3]]
	addXYsByXY(centerPolygon, [2.0, 0.0])
	drawXYPolygon(centerPolygon, getRGB())
//	drillByPolygon(centerPolygon, null, basisXZ, {facets:facets, points:points})
	drillByPolygon(centerPolygon, [-10, 2], basisXZ, {facets:facets, points:points})
	drawXYZPolygons(getPolygonsByFacets(facets, points))
}

function testEquation() {
	console.log('testEquation')
//	var valueString = ' 5 * ( 1 + 1 ) * 3 * ( 2 + 2 ) '
//	var valueString = ' ( 3 % 2 ) * .3 * Math.min(8,11) + getStringLength( testString ) '
//	var valueString = ' 25 + 10 * 1.5 '
//	var valueString = ' -Math.min(8,11) -Math.min(8,11) -Math.min(8,11) '
//	var valueString = ' -Math.min(8,11) **Math.min(8,11) '
//	var valueString = ' -2+1 '
//	var valueString = ' true && false '
//	var valueString = ' 4, '
//	var valueString = ' 1+2*3+4 '
//	var valueString = ' getStringLength( testString ) '
//	var valueString = ' ( 5 % 3 ) + getStringLength( testString ) '
//	var valueString = ' getIntervalsIncludingEnd(0,3.5,1) '
//	var valueString = ' testMap.value '
//	var valueString = ' Math.sin(1) '
//	var valueString = ' Polyline.sineWave(1) '
//	var valueString = ' testArray[0] '
//	var valueString = ' 1,2 '
//	var valueString = ' [[3,5,7],[4,6,8]][0][1] '
//	var valueString = ' [5*[2][0]] '
	var valueString = ' -2e5 '
	var mathMap = new Map([['min', Math.min], ['sin', Math.sin]])
	var polylineMap = new Map([['sineWave', sineWave]])
	var testMap = new Map([['value', '3']])
	getStringLength.optionSet = gSetS
	sineWave.optionSet = null
	var variableMap = new Map([
		['getIntervalsIncludingEnd', getIntervalsIncludingEnd],
		['getStringLength', getStringLength],
		['Polyline', polylineMap],
		['Math', mathMap],
		['test', '2'],
		['testArray', '[3,4]'],
		['testMap', testMap]])
	var parent = {parent:null, variableMap:variableMap}
	var statement = {parent:parent}
	var value = getValueByEquation(null, statement, valueString)
	console.log('value')
	console.log(value)
	console.log(parseFloat('2e5'))
}

function testExpand() {
	console.log('testExpand')
	var pointString = '0,-4,0 0,5,0 4,0,0 9,-4,0'
	var polygon3D = getPointsByString(pointString)
	var heights = [0.0, 1.0]
//	var heights = [0.0, 0.5, 1.0]
	var insets = [[1.0]]
	var mesh = {facets:[], points:[]}
	addToWedgeMesh(heights, insets, mesh, polygon3D)
	var wedgeMesh = getWedgeMesh(heights, insets, [polygon3D], null)
	drawMesh(wedgeMesh)
	console.log('wedgeMesh points')
	console.log(wedgeMesh.points)
	console.log(wedgeMesh.facets)
	var expansionXY = [1.6]
	var expansionZ = 0.0
//	var expansion = [1.6, 1.6, 0.0]
	expandMesh(expansionXY, expansionZ, get3DUnitMatrix(), 1.0, wedgeMesh)
//	drawMesh(wedgeMesh)
//	taperMesh(get3DUnitMatrix(), 2.0, 40.0, 15.5, wedgeMesh)
	drawMesh(wedgeMesh)
}

function testFace() {
	var lines = []
	var pointMap = new Map()
	var tipMap = new Map()
//	var pointString = '0,-1,0 450,-1,0 0,-1,200 0,200,0'
	var pointString = '0,-1,0 9,-1,0 0,-1,4 0,4,0'
	points = getPointsByString(pointString)
	var mesh = {facets:[[0, 1, 2], [0, 2, 3], [1, 3, 2], [0, 3, 1]], points:points}
	var lattice = getXYZLatticeByMesh(mesh)
	var voxelMap = getVoxelMapByXYZLattice(lattice)
//	drawVoxelMap(voxelMap)
	addVoxelLines(2, voxelMap, lines, pointMap, tipMap)
	addVoxelLines(0, voxelMap, lines, pointMap, tipMap)
	addVoxelLines(1, voxelMap, lines, pointMap, tipMap)
//	drawLines(lines, pointMap)
//	drawMesh(getMeshByTipMap(pointMap, tipMap))
	mesh = getJoinedCoplanarMesh(getMeshByTipMap(pointMap, tipMap))
	addXYsByXY(mesh.points, [7, -6])
	drawMesh(mesh)
	drawXYZPoints(mesh.points)


//	var xyzPolygons = getPolygonsByLines(lines, pointMap)
//	drawXYZPolygons(xyzPolygons)
//	var lines = []
//	var pointMap = new Map()
//	var tipMap = new Map()
//	rotateXYZParametersByPoints(2, mesh.points)
//	var xyPolygonsMap = getXYPolygonsMapByMesh(mesh)
//	var voxelMap = getVoxelsByXYPolygonsMap(xyPolygonsMap)
//	addVoxelLines(2, voxelMap, lines, pointMap, tipMap)
//	var xyzPolygons = getPolygonsByLines(lines, pointMap)
//	rotateXYZParametersByPointLists(-2, xyzPolygons)
//	drawXYZPolygons(xyzPolygons)
}

function testFacetSubtraction() {
//	in future facet normal hint for intersections - acceptance angle
//	var pointString = '0,0 0,1 1,0'
	var pointString = '7,-1,0 12,-8,0 7,-5,2 7,-8,0'
	var points = getPointsByString(pointString)
//	var toolString = '10,-9 14,-9 18,-3'
	var toolString = '10,-9 10,-8 14,-9 12,-3'
//	var toolString = '8,-11 14,-11 8,-3'
//	var toolString = '8,-7 9,-7 9,-6.5'
//	var toolString = '8,-6 9,-12 9,5'
//	var toolString = '5,-9 14,-9 5,2'
//	var toolString = '8,-4 10,-7 11,-5'
//	var toolString = '4,-3 9,-3 4,3'
//	var toolString = '8,-6 12,-5 8,-3'
//	var toolString = '8,-4 8,-7 12,-6'
//	var toolString = '8,-4 8,-7 10,-8'
//	var toolString = '8,-6 8,-7 10,-6'
	var toolPolygons = [getPointsByString(toolString)]
//	var toolString = '6,-4 8,-4 8,-3'
//	toolPolygons.push(getPointsByString(toolString))
	var toolPillar = {polygons:toolPolygons, stratas:[[-5, 15]]}
//	var bottomWorkFacets = [[0, 3, 2]]
//	var sideWorkFacets = [[3, 1, 0]]
	var bottomWorkFacets = [[0, 1, 3]]
	var sideWorkFacets = [[3, 2, 0]]
//	var topWorkFacets = [[0, 1, 3]]
//	var topWorkFacets = [[3, 1, 0]]
//	var topWorkFacets = [[1, 2, 3]]
	var topWorkFacets = [[2, 1, 0], [1, 2, 3]]
	var facets = []
	pushArray(facets, bottomWorkFacets)
	pushArray(facets, sideWorkFacets)
	pushArray(facets, topWorkFacets)
	var workMesh = {facets:facets, points:points}
	console.log('workMesh facets')
	console.log(facets.slice(0))
//	sectionByPillar(get3DUnitMatrix(), toolPillar, null, workMesh)
	drillByPillar(get3DUnitMatrix(), toolPillar, null, workMesh)
	drawMesh(workMesh)
//	drawMesh({facets:facets, points:points})
	console.log('facets')
	console.log(facets)
	console.log(workMesh)
	console.log(workMesh.points.length)
	console.log(getMeshAnalysis(workMesh))
}

function testFillet() {
	console.log('testFillet')
	var polygon = getPointsByString('0,-2 0,4 4,4 4,2 2,2 2,0 4,0 4,-2')
	var radius = 2.0
	drawXYPolygon(polygon, getRGB())
	var filletedPolygon = getFilletedPolygon(12, polygon, radius)
	console.log('filletedPolygon')
	console.log(filletedPolygon)
	drawXYPolygon(filletedPolygon, getRGB())
}

function testInset() {
//	var pointString = '0,0 0,4 6,4 6,0'
	var pointString = '0,-2 0,6 1,1 8,-2'
	var xyPolygon = getPointsByString(pointString)
	var insetPolygon = getInsetPolygon([[0.5]], xyPolygon)
	console.log('insetPolygon')
	console.log(insetPolygon)
	drawXYPolygon(xyPolygon, getRGB())
	drawXYPolygon(insetPolygon, getRGB())
}

/*
function testLoop() {
	var lines = []
	var pointMap = new Map()
	var tipMap = new Map()
	var xyPolygonsMap = new Map()
	xyPolygonsMap.set(0, [[[3,-4], [9,-1], [10,-4]]])
	xyPolygonsMap.set(1, [[[3,-4], [9,-1], [10,-4]]])
	var voxelMap = getVoxelsByXYPolygonsMap(xyPolygonsMap)
	drawVoxelMap(voxelMap)
	addVoxelLines(2, voxelMap, lines, pointMap, tipMap)
//	addVoxelLines(0, voxelMap, lines, pointMap, tipMap)
//	addVoxelLines(1, voxelMap, lines, pointMap, tipMap)
	var xyzPolygons = getPolygonsByLines(lines, pointMap)
	drawXYZPolygons(xyzPolygons)
//	drawLines(lines, pointMap)
}
*/

function testMeshBoolean() {
	var pointString = '0,0,0 5,0,0 0,0,4 0,4,0'
	var pointsA = getPointsByString(pointString)
//	addXYsByXY(pointsA, [0.00001, 0.0])
//	addXYZsByZ(pointsA, -0.01777)
	multiplyXYsByScalar(pointsA, 2.0)
	var meshA = {facets:[[0, 1, 2], [0, 2, 3], [1, 3, 2], [0, 3, 1]], points:pointsA}
	var lattice = getXYZLatticeByMesh(meshA)
	var pointStringB = '0,-1,0 6,-1,0 0,-1,4 0,4,0'
	var pointsB = getPointsByString(pointStringB)
	addXYsByXY(pointsB, [1, 0.0])
//	addXYZsByZ(pointsB, -0.000000000000001)
	multiplyXYsByScalar(pointsB, 2.0)
	var meshB = {facets:[[0, 1, 2], [0, 2, 3], [1, 3, 2], [0, 3, 1]], points:pointsB}
	var offsetMultiplier = 0.0
//	var offsetMultiplier = 0.49
//	var layerThickness = 0.100000
	var layerThickness = 0.49999999999999999
	var meshBoolean = null
//	meshBoolean = getMeshAddition(layerThickness, offsetMultiplier, meshA, meshB)
	meshBoolean = getMeshExclusiveIntersection(layerThickness, offsetMultiplier, meshA, meshB)
//	meshBoolean = getMeshIntersection(layerThickness, offsetMultiplier, meshA, meshB)
//	meshBoolean = getMeshSubtraction(layerThickness, offsetMultiplier, meshA, meshB)
	drawMesh(meshBoolean)
//	drawXYZPoints(meshBoolean.points)
	console.log(getMeshAnalysis(meshBoolean))
}

function testOutline() {
	console.log('testOutline')
	var branchAString = '0,0 0,2 0,4'
	var branchA = getPointsByString('0,0 0,2 0,4')
	var branchB = getPointsByString('0,2 2,2 4,4')
	var branches = [branchA, branchB]
	var radius = 0.5
	var outlines = getOutlines(true, [[-2, 0], [0, 2], [2, 0]], [0.2, 0.1], branches)
//	var outlines = getOutlines([[0, 1]], [1.0, 0.5], branches)
//	var outlines = getOutlines(null, [1.0, 0.5], branches)
	drawXYPolylines(branches)
	drawXYPolygons(outlines)
//	var filletedPolygons = getFilletedPolygons(12, outlines, radius)
//	console.log('filletedPolygons')
//	console.log(filletedPolygons)
//	drawXYPolygons(filletedPolygons)
/*
var stringOld = 'file:///home/enrique/projects/mesh/wordscape.html?abstract%20date=20.09.16%20flipY=3%20id=U%20Channel%20project=Wordscape%20Test{%0Avar%20p=point(a%2C1%2C2)%20b=border()%20test=3.5+4%20testA=a%20n=95%20t=10%20tw=2%0Agroup%20transform3D=basis(x%20y)%20id=topView%20transform=translate(border()%2C-topByID()){%0Ascuplture%20analysis=p%20heights=getIntervalsIncludingEnd(0%2C10%2C2)%20view=true%20{%0Alayer%20{%0Apolygon%20nodes=0%205%20t%2C0%205%2C-5%0A}%0Alayer%20copy=%0Alayer%20{%0Apolygon%20nodes=0%203%2C5;1%203%2C-5;3%0Apolygon%20nodes=7%2C5;1%2C0%2010%2C0;2%2C0%207%2C-5;3%2C0%0A}%0Alayer%20{%0Apolygon%20nodes=0%205%205%2C-5%0Apolygon%20nodes=5%2010%2C0%205%2C-5%0A}%0Alayer%20{%0Apolygon%20nodes=0%2C0;0%2C0%205%2C5;1%2C0%2010%2C0;1%2C1%205%2C-5;2%2C0%0A}%0A}%0Aextrusion%20heights=0%2C75+20%20view=true%20{%0Amirror%20points=0%200%2C39%204%2C39%20%2C17%2011%2C14%20perpendicular=17%0A}%0Aemboss%20analysis=p%20work=extrusion%20stratas=50%2C200%20{%0Ascuplture%20analysis=p%20heights=-70%2C-45%2C-45%2C0%20id=scuplture_emboss%20view=true%20{%0Alayer%20{%0Arectangle%20points=4%2030%2C10%0A}%0Alayer%20copy=-1%0Alayer%20{%0Arectangle%20points=4%2C2%2030%2C12%0A}%0Alayer%20copy=-1%0A}%0A}%0A}%0Agroup%20transform3D=basis(x%20z)%20id=frontView%20transform=translate(border()%2C-border()-topByID()-topByID(topView)){%0AcopyMesh%20work=scuplture%20view=true%0AcopyLinear%20work=rectangle%0Amirror%20points=0%200%2C95%20perpendicular=11+6%0Amirror%20points=0%200%2C20%20angle=30%0A_expand%20analysis=polygonal%20copy=true%20expansionXY=1.0+2.0%2C2.0%20expansionZ=1%20view=true%20work=scuplture_emboss%0Aoutline%20outset=5{%0Apolyline%20points=%2C30%20%2C50%20%2C70%0A}%0A}%0Agroup%20transform3D=basis(y%20z)%20id=rightView%20transform=translate(2*border()+rightByID(topView)%2C-border()-topByID()-topByID(topView)){%0Amirror%20points=0%200%2Cn%20perpendicular=19.5%0Apolygon%20points=%2C%2010%2C10+8%2020%2C%20%2C5%0Aweld%20analysis=polygon%20work=extrusion%20stratas=-1%2C70%20{%0Aderive2D%20planes=%2C%20%2C-20%0Averticalhole%20cx=29%20cy=75%20r=test%0A}'
var string = stringOld + stringOld
console.log("Size of sample is: " + string.length);
var compressed = LZString.compressToEncodedURIComponent(string);
//var compressed = LZString.compress(string);
console.log("Size of compressed sample is: " + compressed.length);
string = LZString.decompressFromEncodedURIComponent(compressed);
//string = LZString.decompress(compressed);
console.log("Sample is: " + string);
console.log("Compressed is: " + compressed);
//compressToEncodedURIComponent decompressFromEncodedURIComponent
*/
}

function testPixelBoolean() {
	var lines = []
	var pixelMap = new Map()
	var pointMap = new Map()
	var tipMap = new Map()
	var xyPolygonA = [[0, 0], [0, 4], [4, 0]]
//	var xyPolygonA = [[0, -1], [0, 4], [6, -1]]
	addXYsByXY(xyPolygonA, [6, 0])
//	addTestPixels(pixelMap)
//	createPixelTips(pixelMap)
//	addPixelLines(pixelMap, lines, pointMap, tipMap)
//	var xyPolygons = getPolygonsByLines(lines, pointMap)
	var xyLattice = getXYLattice([xyPolygonA])
//	var xyLattice = getXYLattice(xyPolygons)
//	var xyPolygons = getXYPolygonsByLattice(xyLattice)
//	drawXYPolygon(xyPolygons[0], [255, 0, 0])
//	var pointStringB = '0,-1,0 6,-1,0 0,-1,4 0,4,0'
	var xyPolygonB = [[0, -1], [0, 4], [6, -1]]
	addXYsByXY(xyPolygonB, [10, 0])
//	var xyPolygonB = [[8.5,1.5], [8.5,3.5], [9.5,3.5], [9.5,1.5]]
	var xyLatticeB = getXYLattice([xyPolygonB])
//	console.log(xyLatticeB)
	var xyPolygonBFromLattice = getXYPolygonsByLattice(xyLatticeB)[0]
//	console.log(xyPolygonBFromLattice)
	xyLatticeC = getXYLatticeAddition(xyLattice, xyLatticeB)
//	xyLatticeC = getXYLatticeExclusiveIntersection(xyLattice, xyLatticeB)
//	xyLatticeC = getXYLatticeIntersection(xyLattice, xyLatticeB)
//	xyLatticeC = getXYLatticeSubtraction(xyLattice, xyLatticeB)
	drawPixelMap(getPixelMapByLattice(xyLatticeC[0]))
	var xyPolygonsCFromLattice = getXYPolygonsByLattice(xyLatticeC)
	drawXYPolygons(xyPolygonsCFromLattice)
//	var pointListTest = [[0, 1, 2]]
//	rotateXYZParametersByPoints(2, pointListTest)
}

function testPolygonBoolean() {
	var xyPolygonA = [[0, 0], [4, 0], [0, 4]]
	multiplyXYsByScalar(xyPolygonA, 2.0)
//	var xyPolygonA = [[0, 0], [0, 4], [4, 0]]
//	addXYsByXY(xyPolygonA, [6, 0])
	var xyPolygonB = [[0, -1], [0, 4], [6, -1]]
	addXYsByXY(xyPolygonB, [1, 0])
//	addXYsByXY(xyPolygonB, [9, 0])
	multiplyXYsByScalar(xyPolygonB, 2.0)
//	drawXYPolygons([xyPolygonA])
//	drawXYPolygons([xyPolygonB])
	var layerThickness = 0.05
	var offsetMultiplier = 0.45
	var polygonsBoolean = null
	polygonsBoolean = getPolygonsAddition(layerThickness, offsetMultiplier, [xyPolygonA], [xyPolygonB])
//	polygonsBoolean = getPolygonsExclusiveIntersection(layerThickness, offsetMultiplier, [xyPolygonA], [xyPolygonB])
//	polygonsBoolean = getPolygonsIntersection(layerThickness, offsetMultiplier, [xyPolygonA], [xyPolygonB])
//	polygonsBoolean = getPolygonsSubtraction(layerThickness, offsetMultiplier, [xyPolygonA], [xyPolygonB])
	drawXYPolygons(polygonsBoolean)
}

function testPolygonJoining() {
//	polygonKeyStrings = ['0,0,0 1,1,0 1,0,0', '1,0,0 1,1,0 3,1,0']
//	polygonKeyStrings = ['-1,0,0 -1,2,0 0,2,0 1,1,0 2,2,0 3,2,0 3,0,0', '0,2,0 -1,2,0 -1,4,0 3,4,0 3,2,0 2,2,0 1,3,0']
//	polygonKeyStrings = ['-1,0,0 -1,2,0 0,2,0 1,1,0 2,2,0 3,2,0 4,2,0 5,2,0 6,2,0 4,0,0', '0,2,0 -1,2,0 -1,4,0 3,4,0 6,2,0 5,2,0 4,2,0 3,2,0 2,2,0 1,3,0']
//	polygonKeyStrings = ['0,0,0 -1,0,0 0,1,0', '0,0,0 0,1,0 1,0,0', '0,0,0 1,0,0 0,-1,0', '0,0,0 0,-1,0 -1,0,0']
//	polygonKeyStrings = ['0,-1,0 -1,0,0 0,0,0', '0,-1,0 0,0,0 1,0,0', '-1,0,0 0,1,1 1,0,0 0,0,0']
	var xyPolygonKeyStrings = ['-1,0 -1,2 0,2 1,1 2,2 3,2 4,1 5,2 6,2 6,0', '0,2 -1,2 -1,4 3,4 6,4 6,2 5,2 4,3 3,2 2,2 1,3']
	var xyFacets = getArraysBySplittingStrings(xyPolygonKeyStrings, ' ')
	var joinedFacets = getJoinedFacets(xyFacets)
	var joinedPolygons = convertXYPolygonsToXYZ(convertFacetsToPolygons(joinedFacets), 0)
	var joinedMesh = getMeshByPolygons(joinedPolygons)
	var connectedFacet = getConnectedFacet(joinedMesh.facets, joinedMesh.points)
	drawMesh({facets:[connectedFacet], points:addXYsByXY(joinedMesh.points, [0, -6])})
}

function testRemoveTooThinFacets() {
	console.log('testRemoveTooThinFacets')
//	console.log(getIsXYZSegmentClose([0,0,0], [10,0,-5], [2,0,0]))
//	console.log(getIsXYZSegmentClose([0,0,0], [10,0,-5], [2,0,-1]))
//	console.log(getIsXYZSegmentClose([0,0,0], [10,0,-5], [0,0,0]))
	console.log(getIsXYZSegmentClose([2,0,0], [0,0,0], [1,0,0]))
//	var pointString = '0,0,0 0,0,0 0,1,0 1,0,0'
	var pointString = '0,0,0 1,0,0 2,0,0 3,2,0 3,0,0'
	var points = getPointsByString(pointString)
//	var facets = [[0, 1, 2, 3]]
	var facets = [[0, 1, 2, 3, 4]]
	console.log('points')
	console.log(points)
	console.log(facets)
	var mesh = {facets:facets, points:points}
	removeTooThinFacets(mesh)
	console.log(facets)
}

function testScuplture() {
	// triangulate after adding all facets
	console.log('testScuplture')
	var pointString = '7,-1 12,-8 7,-5 7,-8'
	var points = getPointsByString(pointString)
	var gridMap = new Map()
	var gridMultiplier = getGridMultiplier(gridMap, points)
	var closestPoint = getClosestPoint(gridMap, gridMultiplier, [0.0, 0.0])
//	var closestPoint = getClosestPoint(gridMap, gridMultiplier, [7.0, -1.0])
	console.log('gridMultiplier')
	console.log(gridMultiplier)
	console.log(gridMap)
	console.log(closestPoint)
	var layers = []
	var polynodes = [[{point:[0, 0]}, {point:[0, 6]}, {point:[10, 0]}]]
//	var polynodes = [[{point:[0, 0]}, {point:[5, 5]}, {point:[10, 0]}, {point:[5, -5]}]]
	layers.push({connection:'s', height:0, polynodes:polynodes, transform3D:null})
	polynodes = [
		[{point:[0, 0], connections:null},
		{point:[0, 2], connections:null},
		{point:[0, 6], connections:null},
		{point:[10, 0], connections:null}]]
//		{point:[0, 6], connections:null},
//		{point:[10, 0], connections:null},
//		{point:[2, 2], connections:[]}]]
//	polynodes = [
//		[{point:[0, 0], connections:null},
//		{point:[3, 5], connections:[[1]]},
//		{point:[3, -5], connections:[[3]]}],
//		[{point:[7, 5], connections:[[1, 0]]},
//		{point:[10, 0], connections:[[2, 0]]},
//		{point:[7, -5], connections:[[3, 0]]}]]
	layers.push({connection:'p', height:2, polynodes:polynodes, transform3D:null})
	polynodes = [
		[{point:[0, 0], connections:null},
		{point:[0, 2], connections:null},
		{point:[10, 0], connections:null}]]
//		{point:[0, 6], connections:null},
//		{point:[10, 0], connections:null},
//		{point:[2, 2], connections:null}]]
//	polynodes = [
//		[{point:[0, 0], connections:null},
//		{point:[5, 5], connections:[[1], [0, 1]]},
//		{point:[10, 0], connections:[[1, 1]]},
//		{point:[5, -5], connections:[[2], [2, 1]]}]]
	layers.push({connection:'p', height:4, polynodes:polynodes, transform3D:null})
	console.log(layers)
	var scupltureMesh = getScupltureMesh(layers, get3DUnitMatrix())
	console.log(layers)
	console.log(scupltureMesh)
	drawMesh({facets:scupltureMesh.facets, points:scupltureMesh.points})
}

function testSplitPoints() {
//	var pointString = '0,0,0 0,2,6 4,2,6 4,0,0'
//	var pointString = '0,0,0 0,3,6 4,3,6 4,1,2 2,1,2 2,0,0'
//	var pointString = '0,0,0 0,4,8 4,4,8 4,1,2 2,1,2 2,2,4 1,2,4 1,0,0'
	var pointString = '-4,0,0 -4,4,8 -2,0,0 -2,4,8 0,0,0 0,4,8 4,4,8 4,1,2 2,1,2 2,2,4 1,2,4 1,0,0'
	var points = getPointsByString(pointString)
	var outerFacet = [0, 1, 3, 2]
	var closeFacet = [2, 3, 5, 4]
	var toolFacet = [4, 5, 6, 7, 8, 9, 10, 11]
	var facets = [outerFacet, closeFacet, toolFacet]
	drawXYPolygon(getPolygonByFacet(outerFacet, points), getRGB())
	drawXYPolygon(getPolygonByFacet(closeFacet, points), getRGB())
	drawXYPolygon(getPolygonByFacet(toolFacet, points), getRGB())
	var workMesh = {facets:facets, points:points}
	addSplitIndexesByHeights(2, [2, 3], workMesh)
//	drawXYPolygon(splitPoints, getRGB())
	console.log('splits')
	console.log(workMesh)
	console.log(outerFacet)
	console.log(workMesh.splits)
	drawMesh(workMesh)
}

function testSubtraction() {
	//tested by getSubtractionLoops, used by getSubtractionFaces
//	meeting = {isToolNode, isWorkNode, toolAlong, workAlong}
//	added to meetings at meetingIndex as point from workAlong
//	added to toolMeetingsMap as toolIndex, [toolAlong, meetingIndex]
//	added to workMeetingsMap as workIndex, [workAlong, meetingIndex]
//	sorted by along in both maps
//	polygons divided into {beginIndex, beginPoints, endIndex, endPoints} set in toolSegmentMap and workSegmentMap
//	polygons divided into {beginIndex, beginPoints, endIndex, endPoints} set in toolSegmentMap and workSegmentMap
//	start in work points outside tool, make loops and add if new
//	tool, work..
//	tool:0, 1, 2	work:3, 4, 5	meeting:6, 7
//	polygons = ['8,-9 9,-9 9,-7', '7,-1 12,-8 7,-8']
	polygons = ['8,-8 9,-8 9,-7', '7,-1 12,-8 7,-8']
//	polygons = ['10,-4 10,-5 8,-4.99999995', '7,-1 12,-5 7,-5']
//	polygons = ['10,-4 9,-5 8,-4', '7,-1 12,-5 7,-5']
//	polygons = ['7,-8 9,-3 14,-8', '7,-5 12,-5 7,-1']
//	polygons = ['14,-8 9,-3 7,-8', '7,-5 12,-5 7,-1']
//	polygons = ['14,-8 9,-3 7,-8', '7,-5 12,-5 7,-1']
//	polygons = ['7,-8 9,-5 14,-5.00000025', '7,-5 12,-5 7,-1']
//	polygons = ['5,-5.00000025 10,-5 12,-8', '7,-5 12,-5 7,-1']
//	polygons = ['8,-4 12,-5 12,-8', '7,-5 12,-5 7,-1']
//	polygons = ['8,-7 8,-4 11,-8', '7,-5 12,-5 7,-1']
//	polygons = ['8,-7 10,-5 11,-5', '7,-5 12,-5 7,-1']
//	polygons = ['8,-7 10,-4 12,-6', '7,-5 12,-5 7,-1']
//	polygons = ['8,-17 8,-7 12,-5', '7,-5 12,-5 7,-1']
//	polygons = ['12,-7 12,-3 15,-5', '7,-5 12,-5 7,-1']
//	polygons = ['8,-7 9,-9 9,-6', '7,-1 12,-8 7,-5']
//	polygons = ['8,-4 10,-7 11,-5', '7,-1 12,-5 7,-8']
//	polygons = ['6,-7 7,-3 7,-5 9,-5 10,-5 11,-8', '7,-5 12,-5 7,-1']
//	polygons = ['8,-7 8,-5 9,-5 10,-5 11,-7', '7,-5 8,-5 9,-5 10,-5 12,-5 7,-1']
	convertPointStringsToPointLists(polygons)
	drawXYPolygons(polygons)
	console.log('polygons')
	console.log(polygons)
//	console.log(getPolygonInsideness([8,-7], polygons[0]))
//	console.log(getPolygonInsideness([8.1,-7], polygons[0]))
	var subtractedPolygons = getOperatedPolygons('d', polygons[0], polygons[1])
	console.log('subtractedPolygons')
	console.log(subtractedPolygons)
	drawXYPolygons(subtractedPolygons)
}

function testTaper() {
	console.log('testTaper')
//	var pointString = '0,-4,0 4,3,0 8,-4,0'
	var pointString = '0,-4,0 4,2.92820323,0 8,-4,0'
	var polygon3D = getPointsByString(pointString)
	var heights = [0.0, 1.0]
	var mesh = {facets:[], points:[]}
	addToPillarMesh(heights, mesh, polygon3D)
	var pillarMesh = getPillarMesh([polygon3D], heights, get3DUnitMatrix())
//	drawMesh(pillarMesh)
	console.log('pillarMesh points')
	console.log(pillarMesh.points)
	console.log(pillarMesh.facets)
	taperMesh(get3DUnitMatrix(), 2.0, 40.0, 15.5, pillarMesh)
	drawMesh(pillarMesh)
}

function testTriangleMesh() {
	console.log('testTriangleMesh')
//	var pointString = '0,0,0 0,4,0 4,4,0 4,0,0'
//	var pointString = '0,0,0 0,4,0 4,4,0 1,2,0 4,0,0'
//	var pointString = '0,0,0 0,4,0 4,4,0 4,3,0 1,3,0 1,1,0 4,1,0 4,0,0'
//	var pointString = '-10,-30,0 -10,0,0 -20,0,0 -20,-9,0 -20,-21,0 -20,-30,0'
//	var pointString = '39,-30,0, 17,-30,0, 14,-23,0, 14,-11,0, 17,-4,0, 0,0,0, 0,-34,0, 2,-30,0, 2,-4,0, 12,-4,0, 12,-30,0, 2,-30,0'
//	var pointString = '39,-30,0, 17,-30,0, 14,-23,0, 14,-11,0, 17,-4,0, 0,0,0, 0,-34,0, 2,-30,0, 2,-4,0, 12,-4,0, 12,-30,0, 2,-30,0'
//	var pointString = '34,0,95 34,39,95 30,39,95 30,17,95 23,14,95 11,14,95 4,17,95 4,39,95 0,39,95 0,0,95 34,0,95 30,2,95 4,2,95 4,12,95 30,12,95 30,2,95'
//	var pointString = '-1.5,10.25 -2.5,10.45 -2.5,12.05 -1.5,12.25 1,12.25 1,-12.25 -1.5,-12.25 -2.5,-12.05 -2.5,-10.45 -1.5,-10.25 -1,-10.25 -1,-8.25 -8.333333333333334,-8.25 -8.333333333333334,-10.25 -7.833333333333334,-10.25 -6.833333333333334,-10.45 -6.833333333333334,-12.05 -7.833333333333334,-12.25 -10.833333333333334,-12.25 -11.833333333333334,-12.05 -11.833333333333334,-10.45 -10.833333333333334,-10.25 -10.333333333333334,-10.25 -10.333333333333334,-8.25 -17.666666666666668,-8.25 -17.666666666666668,-10.25 -17.166666666666668,-10.25 -16.166666666666668,-10.45 -16.166666666666668,-12.05 -17.166666666666668,-12.25 -20.166666666666668,-12.25 -21.166666666666668,-12.05 -21.166666666666668,-10.45 -20.166666666666668,-10.25 -19.666666666666668,-10.25 -19.666666666666668,-8.25 -27,-8.25 -27,-10.25 -26.5,-10.25 -25.5,-10.45 -25.5,-12.05 -26.5,-12.25 -29,-12.25 -29,-2.25 -4,-2.2500000000000018 -3,-2.450000000000002 -3,-4.050000000000002 -4,-4.250000000000002 -27,-4.25 -27,-6.25 -1,-6.25 -1,6.25 -27,6.25 -27,1.75 -4,1.7499999999999982 -3,1.549999999999998 -3,-0.05000000000000182 -4,-0.2500000000000018 -29,-0.25 -29,12.25 -26.5,12.25 -25.5,12.05 -25.5,10.45 -26.5,10.25 -27,10.25 -27,8.25 -19.666666666666668,8.25 -19.666666666666668,10.25 -20.166666666666668,10.25 -21.166666666666668,10.45 -21.166666666666668,12.05 -20.166666666666668,12.25 -17.166666666666668,12.25 -16.166666666666668,12.05 -16.166666666666668,10.45 -17.166666666666668,10.25 -17.666666666666668,10.25 -17.666666666666668,8.25 -10.333333333333334,8.25 -10.333333333333334,10.25 -10.833333333333334,10.25 -11.833333333333334,10.45 -11.833333333333334,12.05 -10.833333333333334,12.25 -7.833333333333334,12.25 -6.833333333333334,12.05 -6.833333333333334,10.45 -7.833333333333334,10.25 -8.333333333333334,10.25 -8.333333333333334,8.25 -1,8.25 -1,10.25'
	var pointString = '14.5,-8.444 14.5,-7.556 14.721,-6.697 4.2997705206102536e-16,4.6655377184173457e-17 4.2997705206102536e-16,-39 95,-39 95,4.6655377184173457e-17 4.2997705206102536e-16,4.6655377184173457e-17 14.721,-6.697 15.15,-5.921 15.759,-5.276 16.509,-4.803 17.354,-4.532 18.239,-4.48 19.11,-4.651 19.91,-5.034 21.857,-6.668 21.857,-9.332 19.91,-10.966 19.11,-11.349 18.239,-11.52 17.354,-11.468 16.509,-11.197 15.759,-10.724 15.15,-10.079 14.721,-9.303 14.5,-8.444 11.857,-9.332 9.91,-10.966 9.11,-11.349 8.239,-11.52 7.353999999999999,-11.468 6.509,-11.197 5.759,-10.724 5.15,-10.079 4.721,-9.303 4.5,-8.444 4.5,-7.556 4.721,-6.697 5.15,-5.921 5.759,-5.276 6.509,-4.803 7.353999999999999,-4.532 8.239,-4.48 9.11,-4.651 9.91,-5.034 11.857,-6.668 11.857,-9.332'
	var points = getPointsByString(pointString)
//	var facet = [4, 3, 2, 1, 0]
//	var facet = [0, 1, 2, 3, 4, 5, 6, 7]
//	var facet = [0, 1, 2, 3, 4, 5]
//	var facet = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
	var facet = []
	for (var pointIndex = 0; pointIndex < points.length; pointIndex++) {
		facet.push(pointIndex)
		points[pointIndex].push(0.0)
	}
	addXYsByXY(points, [0,0])
	console.log('getPolygonByFacet(facet, points)')
	console.log(getPolygonByFacet(facet, points))
	multiplyXYZsByScalar(points, 0.5)
	drawXYPolygon(getPolygonByFacet(facet, points), getRGB())
//	rotateXYZParametersByPoints(1, points)
	var triangleFacets = getXYZTriangleFacets(facet, points, new Array(points.length))
	var triangles = getPolygonsByFacets(triangleFacets, points)
//	rotateXYZParametersByPoints(-1, points)
	console.log('triangles')
	console.log(triangles)
	console.log(points)
	drawXYPolygons(triangles)
	var lastTriangle = triangles[triangles.length - 1]
	addXYsByXY(lastTriangle, [2, 0.0])
//	drawXYPolygon(lastTriangle, getRGB())
}

function testVoxel() {
	var lines = []
	var pointMap = new Map()
	var tipMap = new Map()
	var voxelMap = new Map()
	addTestVoxels(voxelMap)
	createTips(voxelMap)
	addVoxelLines(2, voxelMap, lines, pointMap, tipMap)
	addVoxelLines(0, voxelMap, lines, pointMap, tipMap)
	addVoxelLines(1, voxelMap, lines, pointMap, tipMap)
//	drawVoxelMap(voxelMap)
//	drawLines(lines, pointMap)
	var mesh = getMeshByTipMap(pointMap, tipMap)
//	drawMesh(mesh)
	mesh = getJoinedCoplanarMesh(mesh)
	drawMesh(mesh)
	drawXYZPoints(mesh.points)
}

function testVoxelBoolean() {
//	var lines = []
//	var pointMap = new Map()
//	var tipMap = new Map()
	var pointString = '0,0,0 4,0,0 0,0,4 0,4,0'
//	var pointString = '0,0,0 4,0,0 0,0,3 0,4,0'
//	var pointString = '0,1,0 2,1,0 0,1,1 0,2,0'
	var points = getPointsByString(pointString)
	var mesh = {facets:[[0, 1, 2], [0, 2, 3], [1, 3, 2], [0, 3, 1]], points:points}
	var lattice = getXYZLatticeByMesh(mesh)
//	var voxelMap = getVoxelMapByXYZLattice(xyzLattice)
//	addVoxelLines(2, voxelMap, lines, pointMap, tipMap)
//	addVoxelLines(0, voxelMap, lines, pointMap, tipMap)
//	addVoxelLines(1, voxelMap, lines, pointMap, tipMap)
//	mesh = getMeshByTipMap(pointMap, tipMap)
//	mesh = getJoinedCoplanarMesh(mesh)
	mesh = getMeshByLattice(lattice)
//	drawMesh(mesh)
	var linesB = []
	var pointMapB = new Map()
	var tipMapB = new Map()
	var pointStringB = '0,-1,0 6,-1,0 0,-1,4 0,4,0'
//	var pointStringB = '0,-1,0 6,-1,0 0,-1,3 0,4,0'
//	var pointStringB = '0,0,0 6,0,0 0,0,4 0,4,0'
//	var pointStringB = '0,0,0 4,0,0 0,0,1 0,2,0'
	var pointsB = getPointsByString(pointStringB)
	addXYsByXY(pointsB, [1, 0])
	var meshB = {facets:[[0, 1, 2], [0, 2, 3], [1, 3, 2], [0, 3, 1]], points:pointsB}
	var latticeB = getXYZLatticeByMesh(meshB)
	var voxelMapB = getVoxelMapByXYZLattice(latticeB)
	addVoxelLines(2, voxelMapB, linesB, pointMapB, tipMapB)
	addVoxelLines(0, voxelMapB, linesB, pointMapB, tipMapB)
	addVoxelLines(1, voxelMapB, linesB, pointMapB, tipMapB)
	meshB = getMeshByTipMap(pointMapB, tipMapB)
	meshB = getJoinedCoplanarMesh(meshB)
//	drawMesh(meshB)
//	var latticeC = getXYZLatticeAddition(lattice, latticeB)
//	var latticeC = getXYZLatticeExclusiveIntersection(lattice, latticeB)
	var latticeC = getXYZLatticeIntersection(lattice, latticeB)
//	var latticeC = getXYZLatticeSubtraction(lattice, latticeB)
	var linesC = []
	var pointMapC = new Map()
	var tipMapC = new Map()
	var voxelMapC = getVoxelMapByXYZLattice(latticeC)
	drawVoxelMap(voxelMapC)
	addVoxelLines(2, voxelMapC, linesC, pointMapC, tipMapC)
	addVoxelLines(0, voxelMapC, linesC, pointMapC, tipMapC)
	addVoxelLines(1, voxelMapC, linesC, pointMapC, tipMapC)
//	drawLines(linesC, pointMapC)
	var meshC = getMeshByTipMap(pointMapC, tipMapC)
	meshC = getJoinedCoplanarMesh(meshC)
	drawMesh(meshC)
//	console.log(getMeshAnalysis(meshC))
}

function testWedge() {
	console.log('testWedge')
	var pointString = '0,0,0 0,6,0 6,0,0'
	var polygon3D = getPointsByString(pointString)
	var heights = [0.0, 0.5, 1.0]
	var insets = [[1.0]]
	var mesh = {facets:[], points:[]}
	addToWedgeMesh(heights, insets, mesh, polygon3D)
	console.log('points')
	console.log(mesh.points)
	console.log(mesh.facets)
//	drawMesh(mesh)
	var wedgeMesh = getWedgeMesh(heights, insets, [polygon3D], null)
	drawMesh(wedgeMesh)
	console.log('wedgeMesh points')
	console.log(wedgeMesh.points)
	console.log(wedgeMesh.facets)
}

function createSVGTest() {
	document.writeln('<svg height="1100" width="1600">')
	document.writeln('<defs>')
	document.writeln('<marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">')
	document.writeln('<polygon points="0 0, 10 3.5, 0 7" />')
	document.writeln('</marker>')
	document.writeln('</defs>')
	document.writeln('<g style="fill:none;stroke:rgb(0,0,0);stroke-width:0.01" transform="matrix(50,0,0,-50,300,300)">')
//	var before = new Date().getTime()
//	testBend()
//	testConnectedPolygons()
//	testDrillByMesh()
//	testDrillByPolygon()
//	testExpand()
//	testEquation()
//	testFace()
//	testFacetSubtraction()
//	testFillet()
//	testInset()
//	testLoop()
//	testMeshBoolean()
//	testOutline()
//	testPixelBoolean()
//	testPolygonBoolean()
//	testPolygonJoining()
//	testRemoveTooThinFacets()
//	testScuplture()
//	testSplitPoints()
//	testSubtraction()
//	testTaper()
	testTriangleMesh()
//	testVoxel()
//	testVoxelBoolean()
//	testWedge()
//	console.log('Execution time')
//	console.log(new Date().getTime() - before)
	document.writeln('</g>')
	document.writeln('</svg><br>')
}

createSVGTest()
</script>
</body>
</html>
