<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Wordscape</title>
</head>
<body>
<p id="paragraphText"></p>
<button type="button" onclick="update()">Update</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a id="queryLink" href="index.html">Original Link</a><br>
<textarea id="wordArea" rows="20" cols="120"></textarea><br>
<h3>SVG Text</h3>
<textarea id="svgArea" rows="40" cols="120"></textarea><br>
<script>
//License = GNU Affero General Public License http://www.gnu.org/licenses/agpl.html
//rotate, skew, etc.., mirror line y and vector
var gBracketTable = {
	'&lt;':'<',
	'&gt;':'>'}
var gEscapeTable = {
	'%20':' ',
	'%24':'$',
	'%26':'&',
	'%60':'`',
	'%3A':':',
	'%3C':'<',
	'%3E':'>\n',
	'%5B':'[',
	'%5D':']',
	'%7B':'{',
	'%7D':'}',
	'%22':'"',
	'%2B':'+',
	'%23':'#',
	'%25':'%',
	'%40':'@',
	'%2F':'/',
	'%3B':';',
	'%3D':'=',
	'%3F':'?',
	'%5C':'\\',
	'%5E':'^',
	'%7C':'|',
	'%7E':'~',
	'%27':'\'',
	'%2C':','}
var gBracketExpression = new RegExp(Object.keys(gBracketTable).join("|"), "gi")
var gEscapeExpression =	new RegExp(Object.keys(gEscapeTable).join("|"), "gi")
var gNumberOfUpdates = -1

function addSliceToWords(lineSlice, strippedWords) {
	if (lineSlice.indexOf('=') != -1) {
		if (lineSlice.endsWith('>')) {
			if (lineSlice.endsWith('/>')) {
				if (!lineSlice.endsWith(' />')) {
					lineSlice = lineSlice.slice(0, lineSlice.length - 2) + ' />'
				}
			}
			else {
				if (!lineSlice.endsWith(' >')) {
					lineSlice = lineSlice.slice(0, lineSlice.length - 1) + ' >'
				}
			}
		}
	}
	snippets = lineSlice.replace(/=/g, ' = ').split(' ').filter(lengthCheck)
	for (snippet of snippets) {
		strippedWords.push(snippet)
	}
}

function getAttributeLineSetMap(attributeMap, tag) {
	attributeMap.set('_tag_', tag)
	firstWord = '<' + tag
	attributeWords = [firstWord]
	for (entry of attributeMap) {
		key = entry[0]
		if (key != '_tag_') {
			value = entry[1]
			quoteString = '"'
			if (value.indexOf('"') != -1) {
				quoteString = '\''
			}
			attributeWords.push(key + '=' + quoteString + value + quoteString)
		}
	}
	attributeLine = attributeWords.join(' ')
	if (attributeLine.endsWith('"') || attributeLine.endsWith('\'')) {
		return attributeLine + '>'
	}
	return attributeLine + ' >'
}

function getAttributeMap(line) {
	var attributeMap = new Map()
	var strippedWords = getStrippedWords(line)
	if (strippedWords.length > 0) {
		tag = strippedWords[0].slice(1).toLowerCase()
		if (tag.length > 0) {
			if (tag[0] == '/') {
				if (tag.length > 2) {
					attributeMap.set('_endTag_', tag.slice(1, -1))
				}
			}
			else {
				attributeMap.set('_tag_', tag)
			}
		}
	}
	for (wordIndex = 1; wordIndex < strippedWords.length; wordIndex++) {
		if (strippedWords[wordIndex] == '=') {
			attributeMap.set(strippedWords[wordIndex - 1].toLowerCase(), strippedWords[wordIndex + 1])
		}
	}
	return attributeMap
}

function getBracketedEntry(bracketString) {
	indexOfBeginBracket = bracketString.indexOf('(')
	if (indexOfBeginBracket == -1) {
		return ['']
	}
	indexOfEndBracket = bracketString.indexOf(')')
	if (indexOfEndBracket == -1) {
		return ['']
	}
	key = bracketString.slice(0, indexOfBeginBracket).replace(/ /g, '').toLowerCase()
	value = bracketString.slice(indexOfBeginBracket + 1, indexOfEndBracket)
	return [key, value]
}

function getFloats(commaSeparated) {
	return commaSeparated.replace(/,/g, ' ').split(' ').filter(lengthCheck).map(parseFloat)
}

function getFloatValue(attributeMap, defaultValue, key) {
	if (attributeMap.has(key)) {
		return parseFloat(attributeMap.get(key))
	}
	else {
		return defaultValue
	}
}

function getMultiplied2By3Matrix(matrixA, matrixB) {
	// a c e		0 2 4
	// b d f		1 3 5
	// 0 0 1		    +
	// row by column into row, colum
	// [0 2 4] x [0 1  ] = '0,0 2,1' > a > 0
	// [1 3 5] x [0 1  ] = '1,0 3,1' > b > 1
	// [0 2 4] x [2 3  ] = '0,2 2,3' > c > 2
	// [1 3 5] x [2 3  ] = '1,2 3,3' > d > 3
	// [0 2 4] x [4 5 +] = '0,4 2,5 4,' > e > 4
	// [1 3 5] x [4 5 +] = '1,4 3,5 5,' > f > 5
	a = matrixA[0] * matrixB[0] + matrixA[2] * matrixB[1]
	b = matrixA[1] * matrixB[0] + matrixA[3] * matrixB[1]
	c = matrixA[0] * matrixB[2] + matrixA[2] * matrixB[3]
	d = matrixA[1] * matrixB[2] + matrixA[3] * matrixB[3]
	e = matrixA[0] * matrixB[4] + matrixA[2] * matrixB[5] + matrixA[4]
	f = matrixA[1] * matrixB[4] + matrixA[3] * matrixB[5] + matrixA[5]
	return [a, b, c, d, e, f]
}

function getPolygonBoundingBox(attributeMap, matrix) {
	var boundingBox = [Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]
	var points = getPolygonPoints(attributeMap)
	for (point of points) {
		transformPoint(point, matrix)
		boundingBox[0] = Math.min(boundingBox[0], point[0])
		boundingBox[1] = Math.min(boundingBox[1], point[1])
		boundingBox[2] = Math.max(boundingBox[2], point[0])
		boundingBox[3] = Math.max(boundingBox[3], point[1])
	}
	return boundingBox
}

function getPolygonPoints(attributeMap) {
	if (!attributeMap.has('points')) {
		return []
	}
	lastPoint = [0.0, 0.0]
	points = []
	pointWords = attributeMap.get('points').replace(/,/g, ' ').split(' ').filter(lengthCheck)
	for (pointIndex = 0; pointIndex < pointWords.length; pointIndex += 2) {
		pointX = pointWords[pointIndex]
		if (pointX == '~') {
			pointX = lastPoint[0]
		}
		else {
			pointX = parseFloat(pointX)
		}
		yIndex = pointIndex + 1
		if (yIndex < pointWords.length) {
			pointY = pointWords[yIndex]
			if (pointY == '~') {
				pointY = lastPoint[1]
			}
			else {
				pointY = parseFloat(pointY)
			}
			point = [pointX, pointY]
			points.push(point)
			lastPoint = point
		}
	}
	return points
}

function getStrippedWords(line) {
	var quoteSymbols = ['"', '\'']
	var searchIndexes = [-1,-1]
	var start = 0
	var strippedWords = []
	for (whileIndex = 0; whileIndex < 987654; whileIndex++) {
		for (quoteIndex = quoteSymbols.length -1; quoteIndex > -1; quoteIndex--) {
			searchIndex = line.indexOf(quoteSymbols[quoteIndex], start)
			if (searchIndex < 0) {
				searchIndexes.splice(quoteIndex, 1)
				quoteSymbols.splice(quoteIndex, 1)
			}
			else {
				searchIndexes[quoteIndex] = searchIndex
			}
		}
		if (quoteSymbols.length == 0) {
			addSliceToWords(line.slice(start), strippedWords)
			return strippedWords
		}
		firstIndex = searchIndexes[0]
		quoteSymbol = quoteSymbols[0]
		if (searchIndexes[1] < firstIndex) {
			firstIndex = searchIndexes[1]
			quoteSymbol = quoteSymbols[1]
		}
		end = line.indexOf(quoteSymbol, firstIndex + 1)
		if (end < 0) {
			addSliceToWords(line.slice(start), strippedWords)
			return strippedWords
		}
		addSliceToWords(line.slice(start, firstIndex), strippedWords)
		start = end + 1
		strippedWords.push(line.slice(firstIndex + 1, end))
	}
}

function getXYSubtraction(xyA, xyB) {
	return [xyA[0] - xyB[0], xyA[1] - xyB[1]]
}

function group(attributeMap, attributeMaps, commandMap, lineIndex) {
	var height = -Number.MAX_VALUE
	var width = -Number.MAX_VALUE
	var translateX = 0
	for (mapIndex = lineIndex + 1; mapIndex < attributeMaps.length; mapIndex++) {
		nextMap = attributeMaps[mapIndex]
		var points = getPolygonPoints(nextMap)
		for (point of points) {
			height = Math.max(height, point[1])
			width = Math.max(width, point[0])
		}
		if (nextMap.has('_endTag_')) {
			if (nextMap.get('_endTag_') == 'g') {
				mapIndex = attributeMaps.length + 987
			}
		}
	}
	if (attributeMap.has('transform')) {
		var transform = attributeMap.get('transform').toLowerCase()
		if (commandMap.has('group')) {
			commandValues = commandMap.get('group')
			first = commandValues[0]
			firstWidthPlus = first.width + first.translateX + first.translateX
			previous = commandValues[commandValues.length - 1]
			previousWidthPlus = previous.width + previous.translateX + previous.translateX
			heightPlusPreviousString = (previous.height + height + 10).toFixed(0)
			transform = transform.replace('heightplusprevious', heightPlusPreviousString)
			heightPreviousString = (previous.height + 10).toFixed(0)
			transform = transform.replace('heightprevious', heightPreviousString)
			widthPlusPreviousString = (previousWidthPlus + width).toFixed(0)
			transform = transform.replace('widthplusprevious', widthPlusPreviousString)
			widthPreviousString = previousWidthPlus.toFixed(0)
			transform = transform.replace('widthprevious', widthPreviousString)
			heightPlusFirstString = (first.height + height + 10).toFixed(0)
			transform = transform.replace('heightplusfirst', heightPlusFirstString)
			heightFirstString = (first.height + 10).toFixed(0)
			transform = transform.replace('heightfirst', heightFirstString)
			widthPlusFirstString = (firstWidthPlus + width).toFixed(0)
			transform = transform.replace('widthplusfirst', widthPlusFirstString)
			widthFirstString = firstWidthPlus.toFixed(0)
			transform = transform.replace('widthfirst', widthFirstString)
		}
		heightString = (height + 1).toFixed(0)
		transform = transform.replace('height', heightString)
		widthString = (width + 1).toFixed(0)
		transform = transform.replace('width', widthString)
		attributeMap.set('transform', transform)
		var entry = getBracketedEntry(transform)
		if (entry[0] == 'translate') {
			translateX = parseFloat(getFloats(entry[1])[0])
		}
	}
	commandValue = {height:height, translateX:translateX, width:width}
	commandValues = [commandValue]
	if (commandMap.has('group')) {
		commandValues = commandMap.get('group')
		commandValues.push(commandValue)
	}
	commandMap.set('group', commandValues)
	return getAttributeLineSetMap(attributeMap, 'g')
}

function lengthCheck(word) {
	return word.length > 0
}

function matrix(floats) {
	return floats
}

function mirror(attributeMap, attributeMaps, commandMap, lineIndex) {
	points = getPolygonPoints(attributeMap)
	angle = getFloatValue(attributeMap, 0.0, 'angle') * Math.PI / 180.0
	x = getFloatValue(attributeMap, 0.0, 'x')
	y = getFloatValue(attributeMap, 0.0, 'y')
	mirrorFromX = x + x
	for (pointIndex = points.length - 1; pointIndex > -1; pointIndex--) {
		point = points[pointIndex]
		mirrorPoint = [mirrorFromX - point[0], point[1]]
		points.push(mirrorPoint)
	}
	return '<polygon points="' + points.join(' ') + '"/>'
}

function outline(attributeMap, attributeMaps, commandMap, lineIndex) {
	if (!attributeMap.has('style')) {
		attributeMap.set('style', 'fill:none;stroke:rgb(0,0,0);stroke-width:1')
	}
	if (attributeMap.has('flip')) {
		flipScale = [1.0, 1.0]
		floats = getFloats(attributeMap.get('flip'))
		if (floats.length > 0) {
			flipScale = [floats[0], floats[0]]
			if (floats.length > 1) {
				flipScale[1] = floats[1]
			}
		}
		flipScale[1] = -flipScale[1]
		scaleString = 'scale(' + flipScale[0] + ',' + flipScale[1] + ')'
		attributeMap.set('transform', scaleString)
	}
	return getAttributeLineSetMap(attributeMap, 'g')
}

function rotate(floats) {
	if (floats.length == 0) {
		return [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	}
	rotation = floats[0] * Math.PI / 180.0
	cosAngle = Math.cos(rotation)
	sinAngle = Math.sin(rotation)
//	a c e		0 2 4
//	b d f		1 3 5
//	0 0 1		    +
//	cos -sin
//	sin cos
	var latestMatrix = [cosAngle, sinAngle, -sinAngle, cosAngle, 0.0, 0.0]
	if (floats.length < 2) {
		return latestMatrix
	}
	x = 0.0
	y = 0.0
	if (floats.length > 1) {
		x = floats[1]
	}
	if (floats.length > 2) {
		y = floats[2]
	}
	latestMatrix = getMultiplied2By3Matrix(latestMatrix, [1.0, 0.0, 0.0, 1.0, -x, -y])
	return getMultiplied2By3Matrix([1.0, 0.0, 0.0, 1.0, x, y], latestMatrix)
}

function scale(floats) {
	var latestMatrix = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	if (floats.length == 0) {
		return latestMatrix
	}
	latestMatrix[0] = floats[0]
	if (floats.length > 1) {
		latestMatrix[3] = floats[1]
	}
	else {
		latestMatrix[3] = latestMatrix[0]
	}
	return latestMatrix
}

function setMatrix(attributeMap, matrixTags, matrix) {
	if (matrixTags.length > 0) {
		if (attributeMap.has('_endTag_')) {
			endTag = attributeMap.get('_endTag_')
			if (endTag == matrixTags[matrixTags.length - 1].tag) {
				matrixTags.pop()
				return
			}
		}
	}
	if (!attributeMap.has('_tag_')) {
		return
	}
	tag = attributeMap.get('_tag_')
	if (!attributeMap.has('transform')) {
		return
	}
	entry = getBracketedEntry(attributeMap.get('transform'))
	if (entry.length < 2) {
		return
	}
	transformType = entry[0]
	if (!gTransformMap.has(transformType)) {
		return
	}
	var latestMatrix = gTransformMap.get(transformType)(getFloats(entry[1]))
	var matrixTag = {matrix:latestMatrix, tag:tag}
	matrixTags.push(matrixTag)
	if (matrixTags.length > 1) {
		for (index = matrixTags.length - 2; index > -1; index--) {
			latestMatrix = getMultiplied2By3Matrix(matrixTags[index].matrix, latestMatrix)
		}
	}
	for (matrixIndex = 0; matrixIndex < 6; matrixIndex++) {
		matrix[matrixIndex] = latestMatrix[matrixIndex]
	}
//console.log( 'latestMatrix '  + latestMatrix)
}

function setWordArea() {
	var query = document.URL
	indexOfQuestionMark = query.indexOf('?')
	if (indexOfQuestionMark < 0) {
		query = ''
	}
	else {
		query = query.slice(indexOfQuestionMark + 1)
	}
	document.getElementById('wordArea').value = query.replace(gEscapeExpression, function(find) {return gEscapeTable[find]})
}

function skewX(floats) {
	if (floats.length == 0) {
		return [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	}
	var rotation = floats[0] * Math.PI / 180.0
	var tanAngle = Math.tan(rotation)
//	a c e		0 2 4
//	b d f		1 3 5
//	0 0 1		    +
//	1 tan
//	0 1
	return [1.0, 0.0, tanAngle, 1.0, 0.0, 0.0]
}

function skewY(floats) {
	if (floats.length == 0) {
		return [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	}
	var rotation = floats[0] * Math.PI / 180.0
	var tanAngle = Math.tan(rotation)
//	a c e		0 2 4
//	b d f		1 3 5
//	0 0 1		    +
//	1 0
//	tan 1
//console.log( 'skewY '  + [1.0, 0.0, tanAngle, 1.0, 0.0, 0.0])
	return [1.0, tanAngle, 0.0, 1.0, 0.0, 0.0]
}

function transformPoint(point, matrix) {
	originalX = point[0]
	point[0] = point[0] * matrix[0] + point[1] * matrix[1] + matrix[4]
	point[1] = point[1] * matrix[3] + originalX * matrix[2] + matrix[5]
}

function translate(floats) {
	var latestMatrix = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	if (floats.length == 0) {
		return latestMatrix
	}
	latestMatrix[4] = floats[0]
	if (floats.length > 1) {
		latestMatrix[5] = floats[1]
	}
	return latestMatrix
}

function update() {
	var svgString = updateSVGArea()
	document.getElementById('paragraphText').innerHTML = svgString
	var wordString = document.getElementById('wordArea').value
	document.getElementById('queryLink').href = '?' + wordString.replace(/>\n/g, '>')
	gNumberOfUpdates += 1
	if (gNumberOfUpdates > 0) {
		document.getElementById('queryLink').innerHTML = 'Updated Link'
	}
}

function updateSVGArea() {
	var commandMap = new Map()
	var wordString = document.getElementById('wordArea').value
	wordString = wordString.replace(gBracketExpression, function(find) {return gBracketTable[find]})
	var attributeMaps = []
	var convertedMaps = []
	var hasSvg = false
	var lines = wordString.split('\n')
	for (lineIndex = lines.length - 1; lineIndex > -1; lineIndex--) {
		line = lines[lineIndex]
		if (line.length < 3) {
			lines.splice(lineIndex, 1)
		}
	}
	for (lineIndex = 0; lineIndex < lines.length; lineIndex++) {
		line = lines[lineIndex]
		attributeMap = getAttributeMap(line)
		attributeMaps.push(attributeMap)
		firstWord = null
		if (attributeMap.has('_tag_')) {
			tag = attributeMap.get('_tag_')
			if (gTagMap.has(tag)) {
				line = gTagMap.get(tag)(attributeMap, attributeMaps, commandMap, lineIndex)
				lines[lineIndex] = line
			}
			if (tag == 'svg') {
				hasSvg = true
			}
		}
		convertedMap = getAttributeMap(line)
		convertedMaps.push(convertedMap)
	}
	for (lineIndex = 0; lineIndex < lines.length; lineIndex++) {
		convertedMap = convertedMaps[lineIndex]
		if (convertedMap.has('_tag_')) {
			tag = convertedMap.get('_tag_')
			if (gFollowingMap.has(tag)) {
				line = gFollowingMap.get(tag)(convertedMap, convertedMaps, commandMap, lineIndex)
				lines[lineIndex] = line
			}
		}
	}
	if (!hasSvg) {
		var height = 0.0
		var lineThickness = 10
		var width = 0.0
		var matrix = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
		var matrixTags = []
		for (convertedMap of convertedMaps) {
			setMatrix(convertedMap, matrixTags, matrix)
			tag = convertedMap.get('_tag_')
			if (tag == 'polygon') {
				boundingBox = getPolygonBoundingBox(convertedMap, matrix)
				height = Math.max(height, boundingBox[3])
				width = Math.max(width, boundingBox[2])
			}
		}
		height += lineThickness
		width += lineThickness
		svgLine = '<svg height="' + height.toFixed() + '" width="' + width.toFixed() + '" xmlns="http://www.w3.org/2000/svg">'
		lines.splice(0, 0, svgLine)
		lines.push('</svg>')
	}
	var svgString = lines.join('\n')
	document.getElementById('svgArea').rows = lines.length + 2
	document.getElementById('svgArea').value = svgString
	return svgString
}

function verticalHole(attributeMap, attributeMaps, commandMap, lineIndex) {
	angle = getFloatValue(attributeMap, 40.0, 'angle') * Math.PI / 180.0
	cx = getFloatValue(attributeMap, 0.0, 'cx')
	cy = getFloatValue(attributeMap, 0.0, 'cy')
	points = []
	radius = getFloatValue(attributeMap, 1.0, 'r')
	sagAngle = getFloatValue(attributeMap, 15.0, 'sagAngle') * Math.PI / 180.0
	sides = getFloatValue(attributeMap, 24.0, 'sides')
	beginAngle = Math.PI / 2.0 - angle
	endAngle = 1.5 * Math.PI + angle
	maximumIncrement = 2.0 * Math.PI / sides
	deltaAngle = endAngle - beginAngle
	arcSides = Math.ceil(deltaAngle / maximumIncrement - 0.001 * angle)
	angleIncrement = deltaAngle / arcSides
	halfAngleIncrement = 0.5 * angleIncrement
	beginAngle -= halfAngleIncrement
	endAngle += halfAngleIncrement + 0.001 * angle
	outerRadius = radius / Math.cos(0.5 * angleIncrement)
	for (pointAngle = beginAngle; pointAngle < endAngle; pointAngle += angleIncrement) {
		x = cx + Math.sin(pointAngle) * outerRadius
		y = cy + Math.cos(pointAngle) * outerRadius
		points.push([x, y])
	}
	topY = cy + radius
	deltaBegin = getXYSubtraction(points[0], points[1])
	sagRunOverRise = Math.cos(sagAngle) / Math.sin(sagAngle)
	segmentRunOverRise = deltaBegin[0] / deltaBegin[1]
	approachRunOverRise = sagRunOverRise - segmentRunOverRise
	topMinusSegment = topY - points[0][1]
	topX = topMinusSegment * segmentRunOverRise + points[0][0]
	aboveMinusTopY = (topX - cx) / approachRunOverRise
	sagDeltaX = aboveMinusTopY * sagRunOverRise
	aboveY = topY + aboveMinusTopY
	points[0] = [cx + sagDeltaX, aboveY]
	points[points.length - 1] = [cx - sagDeltaX, aboveY]
	for (pointIndex = 0; pointIndex < points.length; pointIndex++) {
		point = points[pointIndex]
		points[pointIndex] = [point[0].toFixed(3), point[1].toFixed(3)]
	}
	return '<polygon points="' + points.join(' ') + '"/>'
}

var gFollowingMap = new Map([
	['group', group]])
var gTagMap = new Map([
	['mirror', mirror],
	['outline', outline],
	['verticalhole', verticalHole]])
var gTransformMap = new Map([
	['matrix', matrix],
	['rotate', rotate],
	['scale', scale],
	['skewx', skewX],
	['skewy', skewY],
	['translate', translate]])
setWordArea()
update()
</script>
</body>
</html>
