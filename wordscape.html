<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Wordscape</title>
</head>
<body>
<p id="paragraphText"></p>
<button type="button" onclick="update()">Update</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<select hidden="true" id="querySelect" onchange ="querySelectChanged()"></select>
<button hidden="true" id="newButton" onclick="windowNew()" type="button">New</button>
<a hidden="true" id="queryLink" href="index.html">Original Link</a><br>
<textarea id="wordArea" rows="20" cols="120"></textarea><br>
<h3>SVG Text</h3>
<textarea id="svgArea" rows="40" cols="120"></textarea><br>
<script src="codec.js"></script>
<script src="help.js"></script>
<script src="matrix.js"></script>
<script>
//License = GNU Affero General Public License http://www.gnu.org/licenses/agpl.html
//view transform3D
//test basis, pillar orientation
//triangleMesh stl=id
//move matrix functions out of mesh
//codeStyle indentation start increment type groupDelimeter
//add circles and rect to bounding box
//set descendants depth with statement
//hidden lines
//replace getXYZCopy with slice(0)
//extrusion layers=[{transform, [polygon]}], closed
//sculpture mosaics=[{transform,[surfaces]}], closed surface={indegons, bottom, top} indegon can be indexed x,y,z;index,id,polygonIndex
//slice svg=id layerThickness=0.6 viewer=none/basic layerHeights=none/[]
//test transform3D
//combination id=a+b-c#d!#e*f/g ** h on vertex
//transform3D extrusionPath(polyline, polygon, polyplane, polyheight)
//mirror line y and vector, polyrect
//setLocal, setGlobal, if switch case else, for
//document.getElementById("wordArea").onkeydown = function(evt) {(evt) ? evt : window.event if (evt.keyCode == 13) {alert("e");}}
//textArea.value.slice(0, textArea.selectionStart).split('\n').length - 1
//deprecated ~ for replace, [ for group ending, [] for id, flip
/*
lastKeyDownCode = null
areaKeyDown = function(evt) {
    (evt) ? evt : window.event
    lastKeyDownCode = evt.keyCode
}

areaInput = function(evt) {
    if (lastKeyDownCode == 13) {
    lines=wordArea.value.split("\n")
    lines[getLineNumber(wordArea)] = '    '
   wordArea.value = lines.join('\n')
    }
}
wordArea.onkeydown = areaKeyDown
wordArea.oninput = areaInput
*/
function addSliceToWords(lineSlice, strippedWords) {
	if (lineSlice.indexOf('=') != -1) {
		lineSlice = getLineWithEndspace(['/>', '>', '[', '{'], lineSlice)
	}
	snippets = lineSlice.replace(/=/g, ' = ').split(' ').filter(lengthCheck)
	for (snippet of snippets) {
		strippedWords.push(snippet)
	}
}

function addToCapitalizationMap(capitalizedWordString) {
	capitalizedWords = capitalizedWordString.split(' ').filter(lengthCheck)
	for (capitalizedWord of capitalizedWords) {
		wordLower = capitalizedWord.toLowerCase()
		if (capitalizedWord != wordLower) {
			gCapitalizationMap.set(wordLower, capitalizedWord)
		}
	}
}

function addToDescendants(descendants, statement) {
	var lengthLimit = 10000000
	if (descendants.length >= lengthLimit) {
		var warningText = 'Recursion limit of\ndescendants reached, no further statements will be processed.'
		var warningVariables = [lengthLimit, statement].concat(descendants.slice(0, 10))
		warning(warningText, warningVariables)
		return
	}
	if (statement.children != null) {
		for (child of statement.children) {
			descendants.push(child)
			addToDescendants(descendants, child)
		}
	}
}

function addToFaces(faces, isTriangular, polygonFace) {
	if (!isTriangular || polygonFace.length < 4) {
		faces.push(polygonFace)
		return
	}
	for (faceIndex = 1; faceIndex < polygonFace.length - 1; faceIndex++) {
		faces.push([polygonFace[0], polygonFace[faceIndex], polygonFace[faceIndex + 1]])
	}
}

function get2DMatrix(attributeMap) {
	if (attributeMap == null) {
		return null
	}
	if (!attributeMap.has('transform')) {
		return null
	}
	entry = getBracketedEntry(attributeMap.get('transform'))
	if (entry == null) {
		return null
	}
	transformType = entry[0]
	if (!g2DTransformMap.has(transformType)) {
		return null
	}
	return g2DTransformMap.get(transformType)(getFloats(entry[1]))
}

function get3DFloats(commaSeparated) {
	return getFloats(commaSeparated.replace(/x/g, '1,0,0').replace(/y/g, '0,1,0').replace(/z/g, '0,0,1'))
}

function get3DMatrix(attributeMap) {
	if (attributeMap == null) {
		return null
	}
	if (!attributeMap.has('transform3D')) {
		return null
	}
	entry = getBracketedEntry(attributeMap.get('transform3D'))
	if (entry == null) {
		return null
	}
	transformType = entry[0]
	if (!g3DTransformMap.has(transformType)) {
		return null
	}
	return g3DTransformMap.get(transformType)(get3DFloats(entry[1]))
}

function getAddition(additionString) {
	var multiplier = 1.0
	var totalValue = 0.0
	var values = additionString.replace(/-/g, ' - ').split('+').join(' + ').split(' ').filter(lengthCheck)
	for (value of values) {
		if (value == '-') {
			multiplier = -1.0
		}
		else {
			if (value == '+') {
				multiplier = 1.0
			}
			else {
				totalValue += parseFloat(value) * multiplier
			}
		}
	}
	return totalValue
}

function getBoundingBox(caller, statement) {
	if (statement.tag == 'polygon') {
		return getPolygonBoundingBox(caller, statement)
	}
	return null
}

function getBracketedEntry(bracketString) {
	indexOfBeginBracket = bracketString.indexOf('(')
	indexOfEndBracket = bracketString.indexOf(')')
	if (indexOfBeginBracket == -1 || indexOfEndBracket == -1 || indexOfBeginBracket > indexOfEndBracket) {
		return null
	}
	return [bracketString.slice(0, indexOfBeginBracket).replace(/ /g, ''), bracketString.slice(indexOfBeginBracket + 1, indexOfEndBracket)]
}

function getCapitalizedKey(key) {
	if (gCapitalizationMap.has(key.toLowerCase())) {
		return gCapitalizationMap.get(key.toLowerCase())
	}
	return key
}

function getDescendants(statement) {
	var descendants = []
	addToDescendants(descendants, statement)
	return descendants
}

function getFloats(commaSeparated) {
	return commaSeparated.replace(/,/g, ' ').split(' ').filter(lengthCheck).map(parseFloat)
}

function getFloatValue(defaultValue, key, registry, statement) {
	attributeMap = statement.attributeMap
	var tagMap = null
	if (registry.defaultMap.has(statement.tag)) {
		tagMap = registry.defaultMap.get(statement.tag)
	}
	else {
		tagMap = new Map()
		registry.defaultMap.set(statement.tag, tagMap)
	}
	tagMap.set(key, defaultValue.toString())
	keyStatement = getKeyStatement(key, statement)
	if (keyStatement == null) {
		return defaultValue
	}
	floatString = keyStatement[1].attributeMap.get(keyStatement[0])
	attributeMap.delete(key)
	return parseFloat(floatString)
}

function getFunctionMapCapitalize(alternatingEntries) {
	var functionMap = new Map()
	for (alternatingIndex = 0; alternatingIndex < alternatingEntries.length; alternatingIndex += 2) {
		key = alternatingEntries[alternatingIndex]
		keyLower = key.toLowerCase()
		if (key != keyLower) {
			gCapitalizationMap.set(keyLower, key)
		}
		nextIndex = alternatingIndex + 1
		value = alternatingEntries[nextIndex]
		functionMap.set(key, value)
	}
	return functionMap
}

function getGroupBoundingBox(caller, statement) {
	var boundingBox = null
	descendants = getDescendants(statement)
	for (child of descendants) {
		var childBox = null
		if (child.tag != null) {
			childBox = getBoundingBox(caller, child)
		}
		if (childBox != null) {
			if (boundingBox == null) {
				boundingBox = [[Number.MAX_VALUE, Number.MAX_VALUE], [-Number.MAX_VALUE, -Number.MAX_VALUE]]
			}
			widenBoundingBox(boundingBox, childBox[0], childBox[1])
		}
	}
	return boundingBox
}

function getIDReplacedBySuffix(bracketString, increment, replacementMap, searchSuffix) {
	searchSuffix = '.' + searchSuffix
	var replacedTokens = []
	var tokens = getTokens('-', [bracketString])
	tokens = getTokens('+', tokens)
	for (token of tokens) {
		indexOfSearchSuffix = token.indexOf(searchSuffix)
		if (indexOfSearchSuffix != -1) {
			beforeSuffix = token.slice(0, indexOfSearchSuffix).trim()
			if (replacementMap.has(beforeSuffix)) {
				value = parseFloat(replacementMap.get(beforeSuffix)) + increment
				replacedTokens.push(value)
			}
			else {
				warningText = 'Error in getIDReplacedBySuffix, could not find id:\nin search string:'
				warningVariables = [beforeSuffix, bracketString]
				warning(warningText, warningVariables)
			}
		}
		else {
			replacedTokens.push(token)
		}
	}
	return replacedTokens.join('')
}

function getIDReplaced(bracketString, increment, replacementMap, searchSuffix) {
	if (bracketString.indexOf(']') == -1) {
		return getIDReplacedBySuffix(bracketString, increment, replacementMap, searchSuffix)
	}
	var splitBracketStrings = bracketString.split(']')
	var replacedStrings = []
	for (splitBracketString of splitBracketStrings) {
		if (splitBracketString.length > 1) {
			var tokens = splitBracketString.split('[')
			if (tokens[0].length > 0) {
				replacedStrings.push(tokens[0])
			}
			var lastToken = tokens[tokens.length - 1].replace(/ /g, '')
			if (replacementMap.has(lastToken)) {
				value = parseFloat(replacementMap.get(lastToken)) + increment
				replacedStrings.push(value)
			}
			else {
				warningText = 'Error in getIDReplaced, could not find id:\nin search string:'
				warningVariables = [lastToken, bracketString]
				warning(warningText, warningVariables)
			}
		}
	}
	return replacedStrings.join('')
}

function getKeyStatement(key, statement) {
	if (statement.attributeMap.has(key)) {
		return [key, statement]
	}
	key = statement.tag + '.' + key
	statement = statement.parent
	for (whileIndex = 0; whileIndex < 987654; whileIndex++) {
		if (statement == null) {
			whileIndex += 987654321
		}
		else {
			if (statement.attributeMap.has(key)) {
				return [key, statement]
			}
			statement = statement.parent
		}
	}
	return null
}

function getLineByStatement(passthrough, statement) {
	if (statement.tag == null) {
		if (statement.nestingIncrement == -1) {
			if (statement.openingStatement == null) {
				return '</g>'
			}
			else {
				if (statement.openingStatement.tag == passthrough) {
					return '</' + passthrough + '>'
				}
				return '</g>'
			}
		}
		else {
			return ''
		}
	}
	firstWord = '<g'
	if (statement.nestingIncrement < 1 || statement.tag == passthrough) {
		firstWord = '<' + statement.tag
	}
	attributeWords = [firstWord]
	for (entry of statement.attributeMap) {
		value = entry[1]
		quoteString = '"'
		if (value.indexOf('"') != -1) {
			quoteString = '\''
		}
		attributeWords.push(entry[0] + '=' + quoteString + value + quoteString)
	}
	attributeLine = attributeWords.join(' ')
	lineClosing = '>'
	if (statement.nestingIncrement == 0) {
		lineClosing = '/>'
	}
	if (attributeLine.endsWith('"') || attributeLine.endsWith('\'')) {
		return attributeLine + lineClosing
	}
	return attributeLine + ' ' + lineClosing
}

function getLineWithEndspace(endWords, line) {
	for (endWord of endWords) {
		if (line.endsWith(endWord)) {
			spaceThenEndWord = ' ' + endWord
			if (!line.endsWith(spaceThenEndWord)) {
				return line.slice(0, line.length - endWord.length) + spaceThenEndWord
			}
		}
	}
	return line
}

function getPillarPolygonMeshes(isTriangular, polygons, polyheight, transform3D) {// unfinished, orientation has not been tested
	if (polygons.length == 0 || polyheight.length == 0) {
		return []
	}
	var meshes = []
	for (polygon of polygons) {
		var faces = []
		var points = []
		if (polygon.length > 0) {
			numberOfParameters = polygon[0].length
			for (heightIndex = 0; heightIndex < polyheight.length; heightIndex += 2) {
				var pointIndexStart = points.length
				var height = polyheight[heightIndex]
				if (numberOfParameters == 2) {
					var polygonFace = []
					for (vertex of polygon) {
						polygonFace.push(points.length)
						points.push([vertex[0], vertex[1], height])
					}
					addToFaces(faces, isTriangular, polygonFace)
					polygonFace = []
					height = polyheight[heightIndex + 1]
					for (vertex of polygon) {
						polygonFace.push(points.length)
						points.push([vertex[0], vertex[1], height])
					}
					polygonFace.reverse()
					addToFaces(faces, isTriangular, polygonFace)
				}
				for (vertexIndex = 0; vertexIndex < polygon.length; vertexIndex++) {
					var bottomLeftIndex = pointIndexStart + vertexIndex
					var bottomRightIndex = pointIndexStart + (vertexIndex + 1) % polygon.length
					var topLeftIndex = bottomLeftIndex + polygon.length
					var topRightIndex = bottomRightIndex + polygon.length
					var polygonFace = [bottomLeftIndex, bottomRightIndex, topLeftIndex, topRightIndex]
					addToFaces(faces, isTriangular, polygonFace)
					pointIndexStart++
				}
			}
		}
		meshes.push({faces:faces, points:points})
	}
	return meshes
}

function getPolygonBoundingBox(caller, statement) {
	var points = getPolygonPoints(statement.attributeMap)
	if (points == null) {
		return null
	}
	var boundingBox = [[Number.MAX_VALUE, Number.MAX_VALUE], [-Number.MAX_VALUE, -Number.MAX_VALUE]]
	var transformedMatrix = getTransformed2DMatrix(caller, statement)
	for (point of points) {
		transform2DPoint(point, transformedMatrix)
		widenBoundingBox(boundingBox, point, point)
	}
	return boundingBox
}

function getPolygonPoints(attributeMap) {
	if (attributeMap == null) {
		return null
	}
	if (!attributeMap.has('points')) {
		return null
	}
	lastPoint = [0.0, 0.0]
	points = []
	pointWords = attributeMap.get('points').replace(/~/g, '*').split('&').join('*,*,*').replace(/,/g, ' ').split(' ').filter(lengthCheck)
	for (pointIndex = 0; pointIndex < pointWords.length; pointIndex += 2) {
		point = lastPoint.slice(0)
		if (pointIndex + 1 < pointWords.length) {
			for (parameterIndex = 0; parameterIndex < 2; parameterIndex++) {
				parameter = pointWords[pointIndex + parameterIndex]
				if (parameter != '*') {
					point[parameterIndex] = parseFloat(parameter)
				}
			}
			points.push(point)
			lastPoint = point
		}
	}
	if (points.length == 0) {
		return null
	}
	return points
}

function getStatement(line) {
	var attributeMap = null
	var children = null
	var nestingIncrement = 0
	var strippedWords = getStrippedWords(line)
	var lastIndex = strippedWords.length - 1
	var tag = null
	if (strippedWords.length > 0) {
		firstWord = strippedWords[0]
		if (firstWord.startsWith('</') || firstWord == ']' || firstWord == '}') {
			nestingIncrement = -1
		}
		else {
			if (firstWord.startsWith('<')) {
				firstWord = firstWord.slice(1)
			}
			if (firstWord.length > 0) {
				tag = getCapitalizedKey(firstWord)
			}
		}
		if (strippedWords.length > 1) {
			var lastWord = strippedWords[lastIndex]
			if (lastWord == '>' || lastWord == '[' || lastWord == '{') {
				nestingIncrement = 1
			}
			if (lastWord.endsWith('>') || lastWord == '[' || lastWord == '{') {
				lastIndex -= 1
			}
		}
	}
	if (tag != null) {
		attributeMap = new Map()
		children = []
		var key = null
		var values = null
		// length = 6
		// last = 4
		// 0 1 2 3 4 5
		// m k = v v e
		for (wordIndex = 2; wordIndex < lastIndex + 1; wordIndex++) {
			var word = strippedWords[wordIndex]
			if (word == '=') {
				if (key != null) {
					attributeMap.set(key, values.slice(0, -1).join(' '))
				}
				key = strippedWords[wordIndex - 1]
				keyStrings = key.split('.')
				if (keyStrings.length == 2) {
					keyStrings[0] = getCapitalizedKey(keyStrings[0])
					keyStrings[1] = getCapitalizedKey(keyStrings[1])
					key = keyStrings.join('.')
				}
				values = []
			}
			else {
				if (values != null) {
					values.push(word)
				}
			}
		}
		if (key != null) {
			attributeMap.set(key, values.join(' '))
		}
	}
	var statement = {
	attributeMap:attributeMap,
	children:children,
	nestingIncrement:nestingIncrement,
	openingStatement:null,
	parent:null,
	tag:tag}
	return statement
}

function getStrippedWords(line) {
	var quoteSymbols = ['"', '\'']
	var searchIndexes = [-1,-1]
	var start = 0
	var strippedWords = []
	for (whileIndex = 0; whileIndex < 987654; whileIndex++) {
		for (quoteIndex = quoteSymbols.length -1; quoteIndex > -1; quoteIndex--) {
			searchIndex = line.indexOf(quoteSymbols[quoteIndex], start)
			if (searchIndex < 0) {
				searchIndexes.splice(quoteIndex, 1)
				quoteSymbols.splice(quoteIndex, 1)
			}
			else {
				searchIndexes[quoteIndex] = searchIndex
			}
		}
		if (quoteSymbols.length == 0) {
			addSliceToWords(line.slice(start), strippedWords)
			return strippedWords
		}
		firstIndex = searchIndexes[0]
		quoteSymbol = quoteSymbols[0]
		if (searchIndexes[1] < firstIndex) {
			firstIndex = searchIndexes[1]
			quoteSymbol = quoteSymbols[1]
		}
		end = line.indexOf(quoteSymbol, firstIndex + 1)
		if (end < 0) {
			addSliceToWords(line.slice(start), strippedWords)
			return strippedWords
		}
		addSliceToWords(line.slice(start, firstIndex), strippedWords)
		start = end + 1
		strippedWords.push(line.slice(firstIndex + 1, end))
	}
}

function getTokens(delimeter, searchStrings) {
	tokens = []
	for (searchString of searchStrings) {
		subTokens = searchString.split(delimeter)
		for (subTokenIndex = 0; subTokenIndex < subTokens.length; subTokenIndex++) {
			tokens.push(subTokens[subTokenIndex])
			if (subTokenIndex < subTokens.length - 1) {
				tokens.push(delimeter)
			}
		}
	}
	return tokens
}

function getTransformed2DMatrix(caller, statement) {
	var transformedMatrix = get2DMatrix(statement.attributeMap)
	for (downIndex = 0; downIndex < 9876; downIndex++) {
		statement = statement.parent
		if (statement == null || statement == caller) {
			if (transformedMatrix == null) {
				return get2DUnitMatrix()
			}
			else {
				return transformedMatrix
			}
		}
		statementMatrix = get2DMatrix(statement.attributeMap)
		if (statementMatrix != null) {
			if (transformedMatrix == null) {
				transformedMatrix = statementMatrix
			}
			else {
				transformedMatrix = getMultiplied2DMatrix(statementMatrix, transformedMatrix)
			}
		}
	}
	return transformedMatrix
}

function lengthCheck(word) {
	return word.length > 0
}

function processDescendants(registry, rootStatement, tagMap) {
	var descendants = [rootStatement]
	addToDescendants(descendants, rootStatement)
	for (statement of descendants) {
		if (tagMap.has(statement.tag)) {
			tagMap.get(statement.tag)(registry, statement)
		}
	}
}

function processGroup(registry, statement) {
	var attributeMap = statement.attributeMap
	var boundingBox = getGroupBoundingBox(statement, statement)
	var height = boundingBox[1][1]
	var width = boundingBox[1][0]
	var border = 0
	if (attributeMap.has('transform')) {
		var transform = attributeMap.get('transform')
		var entry = getBracketedEntry(transform)
		if (entry != null) {
			if (entry[0] == 'translate') {
				commaSeparated = entry[1].split(',')
				var xString = commaSeparated[0]
				var groupStorage = null
				if (registry.storageMap.has('group')) {
					groupStorage = registry.storageMap.get('group')
					xString = xString.replace('border', groupStorage.border.toString())
					xString = getIDReplaced(xString, groupStorage.border + groupStorage.border, groupStorage.widthMap, 'width')
				}
				xString = xString.replace('width', (width + 1).toFixed(0))
				var addition = getAddition(xString)
				if (groupStorage == null) {
					border = addition
				}
				xString = addition.toFixed(0)
				if (commaSeparated.length > 1) {
					yString = commaSeparated[1]
					if (groupStorage != null) {
						yString = getIDReplaced(yString, groupStorage.border, groupStorage.heightMap, 'height')
					}
					yString = yString.replace('height', (height + 1).toFixed(0))
					xString = xString + ',' + getAddition(yString).toFixed(0)
				}
				attributeMap.set('transform', 'translate(' + xString + ')')
			}
		}
	}
	groupStorage = null
	if (registry.storageMap.has('group')) {
		groupStorage = registry.storageMap.get('group')
	}
	else {
		groupStorage = {border:border, heightMap:new Map(), widthMap:new Map()}
		registry.storageMap.set('group', groupStorage)
	}
	if (attributeMap.has('id')) {
		var id = attributeMap.get('id')
		groupStorage.heightMap.set(id, height)
		groupStorage.widthMap.set(id, width)
	}
}

function processMirror(registry, statement) {
	var attributeMap = statement.attributeMap
	angle = getFloatValue(0.0, 'angle', registry, statement) * Math.PI / 180.0
	x = getFloatValue(0.0, 'x', registry, statement)
	y = getFloatValue(0.0, 'y', registry, statement)
	points = getPolygonPoints(attributeMap)
	statement.tag = 'polygon'
	if (points == null) {
		return
	}
	mirrorFromX = x + x
	for (pointIndex = points.length - 1; pointIndex > -1; pointIndex--) {
		point = points[pointIndex]
		mirrorPoint = [mirrorFromX - point[0], point[1]]
		points.push(mirrorPoint)
	}
	attributeMap.set('points', points.join(' '))
}

function processOutline(registry, statement) {
	var attributeMap = statement.attributeMap
	var floats = []
	if (attributeMap.has('flip')) {
		floats = getFloats(attributeMap.get('flip'))
	}
	else {
		if (attributeMap.has('flipY')) {
			floats = getFloats(attributeMap.get('flipY'))
		}
	}
	if (floats.length > 0) {
		scaleString = 'scale(' + floats[0] + ',' + (-floats[0]) + ')'
		attributeMap.set('transform', scaleString)
	}
	var styleMap = new Map([
		['fill', 'none'],
		['stroke', 'rgb(0,0,0)'],
		['stroke-width', '1']])
	if (attributeMap.has('style')) {
		styles = attributeMap.get('style').replace(/ /g, '').split(';')
		for (style of styles) {
			var entry = style.split(':')
			styleMap.set(entry[0], entry[1])
		}
	}
	styles = []
	for (entry of styleMap) {
		styles.push(entry[0] + ':' + entry[1])
	}
	attributeMap.set('style', styles.join(';'))
	titleStrings = []
	if (attributeMap.has('project')) {
		titleStrings.push(attributeMap.get('project'))
	}
	if (attributeMap.has('id')) {
		titleStrings.push(attributeMap.get('id'))
	}
	if (attributeMap.has('date')) {
		titleStrings.push(attributeMap.get('date'))
	}
	titleStrings.push('Wordscape')
	document.title = titleStrings.join(' - ')
}

function processPillar(registry, statement) {
	var attributeMap = statement.attributeMap
	if (!attributeMap.has('polyheight')) {
		return
	}
	polygons = []
	for (child of statement.children) {
		var points = getPolygonPoints(child.attributeMap)
		if (points != null) {
			polygons.push(points)
		}
	}
	polyheight = getFloats(attributeMap.get('polyheight'))
	var pillar = new Pillar(polygons, polyheight, null)
}

function processVerticalHole(registry, statement) {
	var attributeMap = statement.attributeMap
	angle = getFloatValue(40.0, 'angle', registry, statement) * Math.PI / 180.0
	cx = getFloatValue(0.0, 'cx', registry, statement)
	cy = getFloatValue(0.0, 'cy', registry, statement)
	radius = getFloatValue(1.0, 'r', registry, statement)
	sagAngle = getFloatValue(15.0, 'sagAngle', registry, statement) * Math.PI / 180.0
	sides = getFloatValue(24.0, 'sides', registry, statement)
	points = []
	beginAngle = Math.PI / 2.0 - angle
	endAngle = 1.5 * Math.PI + angle
	maximumIncrement = 2.0 * Math.PI / sides
	deltaAngle = endAngle - beginAngle
	arcSides = Math.ceil(deltaAngle / maximumIncrement - 0.001 * angle)
	angleIncrement = deltaAngle / arcSides
	halfAngleIncrement = 0.5 * angleIncrement
	beginAngle -= halfAngleIncrement
	endAngle += halfAngleIncrement + 0.001 * angle
	outerRadius = radius / Math.cos(0.5 * angleIncrement)
	for (pointAngle = beginAngle; pointAngle < endAngle; pointAngle += angleIncrement) {
		x = cx + Math.sin(pointAngle) * outerRadius
		y = cy + Math.cos(pointAngle) * outerRadius
		points.push([x, y])
	}
	topY = cy + radius
	deltaBegin = getXYSubtraction(points[0], points[1])
	sagRunOverRise = Math.cos(sagAngle) / Math.sin(sagAngle)
	segmentRunOverRise = deltaBegin[0] / deltaBegin[1]
	approachRunOverRise = sagRunOverRise - segmentRunOverRise
	topMinusSegment = topY - points[0][1]
	topX = topMinusSegment * segmentRunOverRise + points[0][0]
	aboveMinusTopY = (topX - cx) / approachRunOverRise
	sagDeltaX = aboveMinusTopY * sagRunOverRise
	aboveY = topY + aboveMinusTopY
	points[0] = [cx + sagDeltaX, aboveY]
	points[points.length - 1] = [cx - sagDeltaX, aboveY]
	for (pointIndex = 0; pointIndex < points.length; pointIndex++) {
		point = points[pointIndex]
		points[pointIndex] = [point[0].toFixed(3), point[1].toFixed(3)]
	}
	attributeMap.set('points', points.join(' '))
	statement.tag = 'polygon'
}

function update() {
	var svgString = updateSVGArea()
	document.getElementById('paragraphText').innerHTML = svgString
	setQueryStorage('newButton', 'querySelect', document.getElementById('wordArea').value)
}

function updateSVGArea() {
	var documentRoot = getStatement('documentRoot {')
	var lastParent = documentRoot
	var lines = getBracketReplacedLines('wordArea')
	var registry = {defaultMap:new Map(), idMap:new Map(), storageMap:new Map()}
	var svgStatement = null
	for (lineIndex = 0; lineIndex < lines.length; lineIndex++) {
		line = lines[lineIndex]
		var statement = getStatement(line)
		statement.parent = lastParent
		statement.parent.children.push(statement)
		if (statement.tag != null) {
			var idString = statement.tag
			if (statement.attributeMap.has('id')) {
				idString = statement.attributeMap.get('id')
			}
			else {
				subIdentifiers = []
				var keys = 'cx cy x y r'.split(' ')
				for (key of keys) {
					if (statement.attributeMap.has(key)) {
						subIdentifiers.push(key + statement.attributeMap.get(key))
					}
				}
				if (statement.attributeMap.has('points')) {
					pointStrings = statement.attributeMap.get('points').replace(/,/g, ' ').split(' ').filter(lengthCheck).slice(2, 4)
					subIdentifiers.push(pointStrings.join('-'))
				}
				var parentMap = statement.parent.attributeMap
				if (parentMap.has('id')) {
					idString += '-' + parentMap.get('id')
				}
				subIdentifiers.reverse()
				var suffix = ''
				for (whileIndex = 1; whileIndex < 98765; whileIndex++) {
					check = idString + suffix
					if (registry.idMap.has(check)) {
						if (subIdentifiers.length > 0) {
							idString = idString + '-' + subIdentifiers[subIdentifiers.length - 1]
							subIdentifiers.pop()
						}
						else {
							suffix = '-' + whileIndex.toString()
						}
					}
					else {
						idString = check
						whileIndex += 987654321
					}
				}
				statement.attributeMap.set('id', idString)
			}
			registry.idMap.set(idString, statement)
		}
		if (statement.nestingIncrement == 1) {
			lastParent = statement
		}
		else {
			if (statement.nestingIncrement == -1) {
				if (lastParent.parent == null) {
					lastParent.children.pop(statement)
					warning('Warning, text has too many closing brackets, at lineIndex:', [lineIndex, lastParent, statement])
				}
				else {
					lastParent = lastParent.parent
					statement.openingStatement = statement.parent
				}
			}
		}
		if (svgStatement == null) {
			if (statement.tag == 'svg') {
				svgStatement = statement
			}
		}
	}
	for (childIndex = documentRoot.children.length -1; childIndex > -1; childIndex--) {
		child = documentRoot.children[childIndex]
		if (child.tag == null && child.openingStatement == null) {
			documentRoot.children.splice(childIndex, 1)
		}
	}
	processDescendants(registry, documentRoot, gTag2DMap)
	processDescendants(registry, documentRoot, gTag3DMap)
	processDescendants(registry, documentRoot, gFollowingMap)
	if (svgStatement == null) {
		svgStatement = documentRoot
		svgStatement.tag = 'svg'
		svgEnd = getStatement('</svg>')
		svgStatement.children.push(svgEnd)
		svgEnd.openingStatement = svgStatement
	}
	else {
		documentRoot = null
		svgStatement.parent = null
	}
	var defaultStatement = getStatement('default')
	svgStatement.children.splice(0, 0, defaultStatement)
	defaultStatement.parent = svgStatement
	for (entry of registry.defaultMap) {
		tagMap = entry[1]
		defaultStrings = []
		for (tagEntry of tagMap) {
			defaultStrings.push(tagEntry.join(':'))
		}
		defaultStatement.attributeMap.set(entry[0], defaultStrings.join(';'))
	}
	var descendants = [svgStatement]
	addToDescendants(descendants, svgStatement)
	var lineThickness = 10
	var boundingBox = getGroupBoundingBox(null, svgStatement)
	height = boundingBox[1][1] + lineThickness
	width = boundingBox[1][0] + lineThickness
	if (!svgStatement.attributeMap.has('height')) {
		svgStatement.attributeMap.set('height', height.toFixed())
	}
	if (!svgStatement.attributeMap.has('width')) {
		svgStatement.attributeMap.set('width', width.toFixed())
	}
	if (!svgStatement.attributeMap.has('xmlns')) {
		svgStatement.attributeMap.set('xmlns', 'http://www.w3.org/2000/svg')
	}
	var svgLines = []
	for (statement of descendants) {
		svgLines.push(getLineByStatement('svg', statement))
	}
	joinWord = '\n'
	if (navigator.appVersion.indexOf("Win") > -1) {
		joinWord = '\r\n'
	}
	var svgString = svgLines.join(joinWord)
	setNumberOfRows('wordArea', lines)
	setNumberOfRows('svgArea', svgLines)
	document.getElementById('svgArea').value = svgString
	return svgString
}

function Pillar(polygons, polyheight, transform3D) {
	this.polyheight = polyheight
	this.polygons = polygons
	this.transform3D = transform3D
	this.getPolygonMeshes = function() {return getPillarPolygonMeshes(false, this.polygons, this.polyheight, this.transform3D)}
	this.getTriangleMeshes = function() {return getPillarPolygonMeshes(true, this.polygons, this.polyheight, this.transform3D)}
}

var gCapitalizationMap = new Map()
var gFollowingMap = getFunctionMapCapitalize(['group', processGroup])
var gTag2DMap = getFunctionMapCapitalize([
	'mirror', processMirror,
	'outline', processOutline,
	'verticalHole', processVerticalHole])
var gTag3DMap = getFunctionMapCapitalize(['pillar', processPillar])

addToCapitalizationMap('sagAngle')
setTextArea('wordArea')
update()
</script>
</body>
</html>
