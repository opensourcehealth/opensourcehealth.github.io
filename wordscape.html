<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Wordscape</title>
</head>
<body>
<p id="paragraphText"></p>
<button type="button" onclick="update()">Update</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a id="queryLink" href="index.html">Original Link</a><br>
<textarea id="wordArea" rows="20" cols="120"></textarea><br>
<h3>SVG Text</h3>
<textarea id="svgArea" rows="40" cols="120"></textarea><br>
<script>
//License = GNU Affero General Public License http://www.gnu.org/licenses/agpl.html
var gBracketTable = {
	'&lt;':'<',
	'&gt;':'>'}
var gEscapeTable = {
	'%20':' ',
	'%24':'$',
	'%26':'&',
	'%60':'`',
	'%3A':':',
	'%3C':'<',
	'%3E':'>\n',
	'%5B':'[',
	'%5D':']',
	'%7B':'{',
	'%7D':'}',
	'%22':'"',
	'%2B':'+',
	'%23':'#',
	'%25':'%',
	'%40':'@',
	'%2F':'/',
	'%3B':';',
	'%3D':'=',
	'%3F':'?',
	'%5C':'\\',
	'%5E':'^',
	'%7C':'|',
	'%7E':'~',
	'%27':'â€˜',
	'%2C':','}
var gQuoteEqualTable = {
	'"':' ',
	'\'':' ',
	'=':' = '}
var gBracketExpression = new RegExp(Object.keys(gBracketTable).join("|"), "gi")
var gEscapeExpression =	new RegExp(Object.keys(gEscapeTable).join("|"), "gi")
var gQuoteEqualExpression = new RegExp(Object.keys(gQuoteEqualTable).join("|"), "gi")
var gNumberOfupdates = -1

function getFloatValue(defaultValue, key, valueMap) {
	if (valueMap.has(key)) {
		return parseFloat(valueMap.get(key))
	}
	else {
		return defaultValue
	}
}

function getValueMap(line) {
	var valueMap = new Map()
	words = line.replace(gQuoteEqualExpression, function(find) {return gQuoteEqualTable[find]}).split(' ')
	words = words.filter(function(word) {return word.length>0});
	for (wordIndex = 1; wordIndex < words.length; wordIndex++) {
		word = words[wordIndex]
		if (word == '=') {
			valueMap.set(words[wordIndex - 1].toLowerCase(), words[wordIndex + 1])
		}
	}
	return valueMap
}

function getXYSubtraction(xyA, xyB) {
	return [xyA[0] - xyB[0], xyA[1] - xyB[1]]
}

function setWordArea() {
	var query = document.URL
	indexOfQuestionMark = query.indexOf('?')
	if (indexOfQuestionMark < 0) {
		query = ''
	}
	else {
		query = query.slice(indexOfQuestionMark + 1)
	}
	document.getElementById('wordArea').value = query.replace(gEscapeExpression, function(find) {return gEscapeTable[find]})
}

function update() {
	var svgString = updateSVGArea()
	document.getElementById('paragraphText').innerHTML = svgString
	var wordString = document.getElementById('wordArea').value
	document.getElementById('queryLink').href = '?' + wordString.replace('>\n', '>')
	gNumberOfupdates += 1
	if (gNumberOfupdates > 0) {
		document.getElementById('queryLink').innerHTML = 'Updated Link'
	}
}

function updateSVGArea() {
	var wordString = document.getElementById('wordArea').value
	wordString = wordString.replace(gBracketExpression, function(find) {return gBracketTable[find]})
	var lines = wordString.split('\n')
	for (lineIndex = 0; lineIndex < lines.length; lineIndex++) {
		line = lines[lineIndex]
		indexOfSpace = line.indexOf(' ')
		if (indexOfSpace > 0) {
			startWord = line.slice(1, indexOfSpace).toLowerCase()
			if (gTagMap.has(startWord)) {
				lines[lineIndex] = gTagMap.get(startWord)(line)
			}
		}
	}
	var svgString = lines.join('\n')
	document.getElementById('svgArea').value = svgString
	return svgString
}

function verticalHole(line) {
	valueMap = getValueMap(line)
	angle = getFloatValue(40.0, 'angle', valueMap) * Math.PI / 180.0
	cx = getFloatValue(0.0, 'cx', valueMap)
	cy = getFloatValue(0.0, 'cy', valueMap)
	points = []
	radius = getFloatValue(1.0, 'r', valueMap)
	sagAngle = getFloatValue(30.0, 'sagangle', valueMap) * Math.PI / 180.0
	sides = getFloatValue(12.0, 'sides', valueMap)
	beginAngle = Math.PI / 2.0 - angle
	endAngle = 1.5 * Math.PI + angle
	maximumIncrement = 2.0 * Math.PI / sides
	deltaAngle = endAngle - beginAngle
	arcSides = Math.ceil(deltaAngle / maximumIncrement - 0.001 * angle)
	angleIncrement = deltaAngle / arcSides
	halfAngleIncrement = 0.5 * angleIncrement
	beginAngle -= halfAngleIncrement
	endAngle += halfAngleIncrement + 0.001 * angle
	outerRadius = radius / Math.cos(0.5 * angleIncrement)
	for (pointAngle = beginAngle; pointAngle < endAngle; pointAngle += angleIncrement) {
		x = cx + Math.sin(pointAngle) * outerRadius
		y = cy + Math.cos(pointAngle) * outerRadius
		points.push([x, y])
	}
	topY = cy + radius
	deltaBegin = getXYSubtraction(points[0], points[1])
	sagRunOverRise = Math.cos(sagAngle) / Math.sin(sagAngle)
	segmentRunOverRise = deltaBegin[0] / deltaBegin[1]
	approachRunOverRise = sagRunOverRise - segmentRunOverRise
	topMinusSegment = topY - points[0][1]
	topX = topMinusSegment * segmentRunOverRise + points[0][0]
	aboveMinusTopY = (topX - cx) / approachRunOverRise
	sagDeltaX = aboveMinusTopY * sagRunOverRise
	aboveY = topY + aboveMinusTopY
	points[0] = [cx + sagDeltaX, aboveY]
	points[points.length - 1] = [cx - sagDeltaX, aboveY]
	for (pointIndex = 0; pointIndex < points.length; pointIndex++) {
		point = points[pointIndex]
		points[pointIndex] = [point[0].toFixed(3), point[1].toFixed(3)]
	}
	return '<polygon points="' + points.join(' ') + '" />'
}

var gTagMap = new Map()
gTagMap.set('verticalhole', verticalHole)

setWordArea()
update()
</script>
</body>
</html>
