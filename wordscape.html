<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Wordscape</title>
</head>
<body>
<table>
<tr>
<th><p id="paragraphText"></p></th><th><canvas id="viewerCanvas" width="400" height="300" style="border:1px solid black"></canvas></th>
</tr>
</table>
<table style="width:50%">
<tr>
<td><button type="button" onclick="update()">Update</button><td>
<td><select hidden="true" id="querySelect" onchange ="querySelectChanged()"></select><td>
<td><button hidden="false" id="newButton" onclick="windowNew()" type="button">New</button><td>
<td><select hidden="true" id="viewSelect" onchange ="viewSelectChanged()"></select><td>
</tr>
<tr>
<td><button hidden="true" type="button"></button><td>
<td><select hidden="true"></select><td>
<td><a hidden="true" id="queryLink" href="index.html">Original Link</a><td>
<td><select hidden="true" id="typeSelect" onchange ="typeSelectChanged()"></select></td>
</tr>
</table>
<textarea id="wordArea" rows="20" cols="120"></textarea><br>
<br>
<h3>SVG</h3>
<textarea id="svgArea" rows="40" cols="120"></textarea><br>
<br>
<h3>Mesh</h3>
<textarea id="meshArea" rows="10" cols="120"></textarea><br>
<br>
<script src="maparray.js"></script>
<script src="alteration.js"></script>
<script src="construction.js"></script>
<script src="codec.js"></script>
<script src="evaluation.js"></script>
<script src="help.js"></script>
<script src="generator2d.js"></script>
<script src="generator3d.js"></script>
<script src="lzstring.js"></script>
<script src="matrix.js"></script>
<script src="meta.js"></script>
<script src="parsenumber.js"></script>
<script src="parseword.js"></script>
<script src="polygon.js"></script>
<script src="polyhedron.js"></script>
<script src="statement.js"></script>
<script src="viewer.js"></script>
<script>
//License = GNU Affero General Public License http://www.gnu.org/licenses/agpl.html
//
//subtraction xyz
//change exterior to voxel and pixel
//layers=[{transform, [polygon]}], closed, plane
//test basis, transform in pillar
//verticalHole should be widdershins, all widdershins should be reversed when making a mesh when on outside
//analyze volume and surface area
//view transform3D
//hidden lines
//sculpture mosaics=[{transform,[surfacets]}], closed surfacet={indegons, bottom, top} indegon can be indexed x,y,z;index,id,polygonIndex
//slice svg=id layerThickness=0.6 viewer=none/basic layerHeights=none/[]
//test transform3D
//combination id=a+b-c#d!#e*f/g ** h on vertex
//add circles and rect to bounding box
//check backslash quote in quoteSeparated
//codeStyle indentation start increment type groupDelimeter
//wireframe/solid choice, instructions, 3D direction display, settings, wait, animation, separate polygons option
//set descendants depth with statement
//extrusion sort closest before splicing if they are both on same edge arrowindexsetmap only needed with thin shapes
//transform3D extrusionPath(heights, polyline, polygon, polyplane)
//maybe outputTriangleMesh stl=id, nextID..
//mirror line y and vector, polyrect
//setLocal, setGlobal, if switch case else, for
//outset, shell, tile, venturi, helix, unlimited, terrain, road
//gear/wheel, wing, propeller, pipe/pail, pulley/cable, chair/shelf, gores?, lattice?, haxagonal extrusion
//humanoid, quadruped, door/window, lamp/chandelier, gemstone, press, arch, column, pontoon, box, shoe/hat, ribs/umbrella, house
//wrench/screwdriver, alteration machine
//document.getElementById("wordArea").onkeydown = function(evt) {(evt) ? evt : window.event if (evt.keyCode == 13) {alert("e");}}
//textArea.value.slice(0, textArea.selectionStart).split('\n').length - 1
//deprecated flip
/*
lastKeyDownCode = null
areaKeyDown = function(evt) {
    (evt) ? evt : window.event
    lastKeyDownCode = evt.keyCode
}

areaInput = function(evt) {
    if (lastKeyDownCode == 13) {
    lines=wordArea.value.split("\n")
    lines[getLineNumber(wordArea)] = '    '
   wordArea.value = lines.join('\n')
    }
}
wordArea.onkeydown = areaKeyDown
wordArea.oninput = areaInput
*/

function addToMeshArea(meshString) {
	if (meshString == null) {
		return
	}
	var meshArea = document.getElementById('meshArea')
	if (meshArea.value == '') {
		meshArea.value = meshString
		return
	}
	meshArea.value = meshArea.value + '\n' + meshString
}

//deprecated
function analyzeOutputMesh(meshGenerator, registry, statement) {
	var attributeMap = statement.attributeMap
	var id = attributeMap.get('id')
	registry.objectMap.set(id, meshGenerator)
	alterMeshExcept(meshGenerator.getMesh(), registry, statement, statement.tag)
	var date = getNullOrValue('date', registry.storageMap)
	var project = getNullOrValue('project', registry.storageMap)
	if (attributeMap.has('outputMesh')) {
		addToMeshArea(getMeshString(date, attributeMap.get('outputMesh'), id, meshGenerator.getMesh(), project))
	}
	if (attributeMap.has('outputTriangleMesh')) {
		addToMeshArea(getTriangleMeshString(date, attributeMap.get('outputTriangleMesh'), id, meshGenerator.getMesh(), project))
	}
	if (attributeMap.has('view')) {
		if (getBooleanByStatementValue('view', registry, statement, attributeMap.get('view'))) {
			meshViewer.addMesh(id, null)
		}
	}
}

function getGroupBoundingBox(caller, registry, statement) {
	var boundingBox = null
	var descendants = []
	addToDescendantsInsideFirst(descendants, statement)
	for (var child of descendants) {
		boundingBox = widenStatementBoundingBox(boundingBox, caller, registry, child)
	}
	return boundingBox
}

function getInsets(registry, statement) {
	var insets = getPointsByTag('insets', registry, statement, 'polygon')
	if (insets == null) {
		return [[1.0]]
	}
	return insets
}

function getMeshesByChildren(children, registry) {
	var meshes = []
	for (var child of children) {
		var attributeID = child.attributeMap.get('id')
		if (registry.objectMap.has(attributeID)) {
			meshes.push(registry.objectMap.get(attributeID).getMesh())
		}
	}
	return meshes
}

function getPolygonsRecursively(registry, statement) {
	return getPointListsRecursively('points', registry, statement, 'polygon')
}

function getStratas(registry, statement) {
	var stratas = getFloatListsByStatement('stratas', registry, statement)
	if (getIsEmpty(stratas)) {
		return [null]
	}
	return stratas
}

function getTransform2DsByChildren(children, registry) {
	var transform2DsByChildren = null
	for (var child of children) {
		var transform2Ds = getPointsByTag('transform2Ds', registry, child, 'derive2D')
		if (!getIsEmpty(transform2Ds)) {
			if (transform2DsByChildren == null) {
				transform2DsByChildren = transform2Ds
			}
			else {
				pushArray(transform2DsByChildren, transform2Ds)
			}
		}
		var transform2Ds = getPointsByTag('transform2Ds', registry, child, 'transform2D')
		if (!getIsEmpty(transform2Ds)) {
			if (transform2DsByChildren == null) {
				transform2DsByChildren = transform2Ds
			}
			else {
				pushArray(transform2DsByChildren, transform2Ds)
			}
		}
	}
	return transform2DsByChildren
}

function getWorkMesh(registry, statement) {
	var attributeMap = statement.attributeMap
	if (!attributeMap.has('work')) {
		return null
	}
	var workID = attributeMap.get('work')
	if (!registry.objectMap.has(workID)) {
		return null
	}
	var workGenerator = registry.objectMap.get(workID)
	if (workGenerator == null) {
		return null
	}
	var workMesh = workGenerator.getMesh()
	if (attributeMap.has('copy')) {
		if (getBooleanByStatementValue('copy', registry, statement, attributeMap.get('copy'))) {
			workMesh = getMeshCopy(workMesh)
		}
	}
	return workMesh
}

function update() {
	document.getElementById('meshArea').value = ''
	var svgString = updateSVGArea()
	document.getElementById('paragraphText').innerHTML = svgString
	setQueryStorage('newButton', 'querySelect', document.getElementById('wordArea').value)
}

function updateSVGArea() {
	var lines = getBracketReplacedLines('wordArea')
	var registry = {idMap:new Map(), objectMap:new Map(), storageMap:new Map()}
	meshViewer.setID('viewerCanvas', registry.objectMap, 'typeSelect', 'viewSelect')
	var svgStatement = getDocumentRoot(lines, 'svg')
	var descendants = [svgStatement]
	addToDescendantsOutsideFirst(descendants, svgStatement)
	for (var statement of descendants) {
		if (statement.tag != null) {
			getStatementID(registry, statement)
		}
	}
	createDefault(registry, svgStatement)
	processDescendantsByTagMap(registry, svgStatement, gTagBeginMap)
	processDescendantsByTagMap(registry, svgStatement, gTagCenterMap)
	var descendants = [svgStatement]
	addToDescendantsOutsideFirst(descendants, svgStatement)
	var lineThickness = 10
	var boundingBox = getGroupBoundingBox(null, registry, svgStatement)
	var height = lineThickness
	var padding = 5
	var width = lineThickness
	if (boundingBox != null) {
		height += boundingBox[1][1]
		width += boundingBox[1][0] + lineThickness
	}
	height = Math.max(height, 300)
	width = Math.max(width, 300)
	if (!svgStatement.attributeMap.has('height')) {
		svgStatement.attributeMap.set('height', height.toFixed())
	}
	if (!svgStatement.attributeMap.has('style')) {
		svgStatement.attributeMap.set('style', 'border:1px solid black;padding:' + padding.toString() + 'px')
	}
	if (!svgStatement.attributeMap.has('width')) {
		svgStatement.attributeMap.set('width', width.toFixed())
	}
	if (!svgStatement.attributeMap.has('xmlns')) {
		svgStatement.attributeMap.set('xmlns', 'http://www.w3.org/2000/svg')
	}
	var svgLines = getPassthroughLines(descendants, 'svg')
	var joinWord = getJoinWord()
	var svgString = svgLines.join(joinWord)
	setNumberOfRows('wordArea', lines)
	setNumberOfRows('svgArea', svgLines)
	document.getElementById('svgArea').value = svgString
	meshViewer.start(height + padding + padding)
	return svgString
}

var gTagBeginMap = new Map()
var gTagCenterMap = new Map()
gProcessors = gAlterationProcessors.concat(gConstructionProcessors).concat(gGenerator2DProcessors)
gProcessors = gProcessors.concat(gGenerator3DProcessors).concat(gMetaProcessors)
initializeProcessors(gProcessors)

setTextArea('wordArea')
update()
</script>
</body>
</html>
