<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Wordscape</title>
</head>
<body>
<p id="paragraphText"></p>
<button type="button" onclick="update()">Update</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a id="queryLink" href="index.html">Original Link</a><br>
<textarea id="wordArea" rows="20" cols="120"></textarea><br>
<h3>SVG Text</h3>
<textarea id="svgArea" rows="40" cols="120"></textarea><br>
<script>
//License = GNU Affero General Public License http://www.gnu.org/licenses/agpl.html
//add children to bounding box
//view transform3D
//extrude(true) pillar(transform, [polygon], polyheight)
//mesh stl=id
//add circles and rect to bounding box
//hidden lines
//extrusion(layers=[(transform, [polygon], layers, closedTop)], closed) polygon can be indexed x,y,index
//slice svg=id layerThickness=0.6 viewer=none/basic layerHeights=none/[]
//combination id=a+b-c*d/e ** on vertex transform3D extrusionPath(polyline, polygon, polyplane, polyheight)
//mirror line y and vector, polyrect
//setLocal, setGlobal, if switch case else, for
//codeStyle indentation start increment type groupDelimeter, switch [] to {}
//matrix2D, transform3D basis
//document.getElementById("wordArea").onkeydown = function(evt) {(evt) ? evt : window.event if (evt.keyCode == 13) {alert("e");}}
//textArea.value.slice(0, textArea.selectionStart).split('\n').length - 1
/*
lastKeyDownCode = null
areaKeyDown = function(evt) {
    (evt) ? evt : window.event
    lastKeyDownCode = evt.keyCode
}

areaInput = function(evt) {
    if (lastKeyDownCode == 13) {
    lines=wordArea.value.split("\n")
    lines[getLineNumber(wordArea)] = '    '
   wordArea.value = lines.join('\n')
    }
}
wordArea.onkeydown = areaKeyDown
wordArea.oninput = areaInput
*/
var gBracketTable = {
	'&lt;':'<',
	'&gt;':'>'}
var gEscapeTable = {
	'%0A':'\n',
	'%0D':'\r',
	'%20':' ',
	'%24':'$',
	'%26':'&',
	'%60':'`',
	'%3A':':',
	'%3C':'<',
	'%3E':'>',
	'%5B':'[',
	'%5D':']',
	'%7B':'{',
	'%7D':'}',
	'%22':'"',
	'%2B':'+',
	'%23':'#',
	'%25':'%',
	'%40':'@',
	'%2F':'/',
	'%3B':';',
	'%3D':'=',
	'%3F':'?',
	'%5C':'\\',
	'%5E':'^',
	'%7C':'|',
	'%7E':'~',
	'%27':'\'',
	'%2C':','}
var gBracketExpression = new RegExp(Object.keys(gBracketTable).join("|"), "gi")
var gEscapeExpression =	new RegExp(Object.keys(gEscapeTable).join("|"), "gi")
var gNumberOfUpdates = -1

function addSliceToWords(lineSlice, strippedWords) {
	if (lineSlice.indexOf('=') != -1) {
		lineSlice = getLineWithEndspace(['/>', '>', '[', '{'], lineSlice)
	}
	snippets = lineSlice.replace(/=/g, ' = ').split(' ').filter(lengthCheck)
	for (snippet of snippets) {
		strippedWords.push(snippet)
	}
}

function addToCapitalizationMap(capitalizedWordString) {
	capitalizedWords = capitalizedWordString.split(' ').filter(lengthCheck)
	for (capitalizedWord of capitalizedWords) {
		wordLower = capitalizedWord.toLowerCase()
		if (capitalizedWord != wordLower) {
			gCapitalizationMap.set(wordLower, capitalizedWord)
		}
	}
}

function deleteKeys(keyString, mapToRemoveFrom) {
	keys = keyString.split(' ')
	for (key of keys) {
		mapToRemoveFrom.delete(key)
	}
}

function getAddition(additionString) {
	var multiplier = 1.0
	var totalValue = 0.0
	var values = additionString.replace(/-/g, ' - ').split('+').join(' + ').split(' ').filter(lengthCheck)
	for (value of values) {
		if (value == '-') {
			multiplier = -1.0
		}
		else {
			if (value == '+') {
				multiplier = 1.0
			}
			else {
				totalValue += parseFloat(value) * multiplier
			}
		}
	}
	return totalValue
}

function getBracketedEntry(bracketString) {
	entry = bracketString.split(')')
	if (entry.length < 2) {
		return ['']
	}
	entry = entry[0].split('(')
	if (entry.length < 2) {
		return ['']
	}
	return [entry[0].replace(/ /g, ''), entry[1]]
}

function getCapitalizedKey(key) {
	if (gCapitalizationMap.has(key.toLowerCase())) {
		return gCapitalizationMap.get(key.toLowerCase())
	}
	return key
}

function getFloats(commaSeparated) {
	return commaSeparated.replace(/,/g, ' ').split(' ').filter(lengthCheck).map(parseFloat)
}

function getFloatValue(defaultValue, key, statement) {
	if (statement.attributeMap.has(key)) {
		return parseFloat(statement.attributeMap.get(key))
	}
	parentKey = statement.tag + '.' + key
	var parent = statement.parent
	for (whileIndex = 0; whileIndex < 987654; whileIndex++) {
		if (parent == null) {
			whileIndex += 987654321
		}
		else {
			parentAttributeMap = parent.attributeMap
			if (parentAttributeMap.has(parentKey)) {
				return parseFloat(parentAttributeMap.get(parentKey))
			}
			parent = parent.parent
		}
	}
	return defaultValue
}

function getFunctionMapCapitalize(alternatingEntries) {
	var functionMap = new Map()
	for (alternatingIndex = 0; alternatingIndex < alternatingEntries.length; alternatingIndex += 2) {
		key = alternatingEntries[alternatingIndex]
		keyLower = key.toLowerCase()
		if (key != keyLower) {
			gCapitalizationMap.set(keyLower, key)
		}
		nextIndex = alternatingIndex + 1
		value = alternatingEntries[nextIndex]
		functionMap.set(key, value)
	}
	return functionMap
}

function getIDReplaced(bracketString, increment, replacementMap) {
	if (bracketString.indexOf(']') == -1) {
		return bracketString
	}
	var splitBracketStrings = bracketString.split(']')
	var replacedStrings = []
	for (splitBracketString of splitBracketStrings) {
		if (splitBracketString.length > 1) {
			var tokens = splitBracketString.split('[')
			if (tokens[0].length > 0) {
				replacedStrings.push(tokens[0])
			}
			var lastToken = tokens[tokens.length - 1].replace(/ /g, '')
			if (replacementMap.has(lastToken)) {
				value = parseFloat(replacementMap.get(lastToken)) + increment
				replacedStrings.push(value)
			}
			else {
				console.log('Error in getIDReplaced, could not find id:' + lastToken)
				console.log('Search string is:' + bracketString)
			}
		}
	}
	return replacedStrings.join('')
}

function getLineByStatement(statement) {
	if (statement.tag == null) {
		if (statement.nestingIncrement == -1) {
			if (statement.openingStatement == null) {
				return '</g>'
			}
			else {
				return '</' + statement.openingStatement.tag + '>'
			}
		}
		else {
			return ''
		}
	}
	firstWord = '<' + statement.tag
	attributeWords = [firstWord]
	for (entry of statement.attributeMap) {
		value = entry[1]
		quoteString = '"'
		if (value.indexOf('"') != -1) {
			quoteString = '\''
		}
		attributeWords.push(entry[0] + '=' + quoteString + value + quoteString)
	}
	attributeLine = attributeWords.join(' ')
	lineClosing = '>'
	if (statement.nestingIncrement == 0) {
		lineClosing = '/>'
	}
	if (attributeLine.endsWith('"') || attributeLine.endsWith('\'')) {
		return attributeLine + lineClosing
	}
	return attributeLine + ' ' + lineClosing
}

function getLineWithEndspace(endWords, line) {
	for (endWord of endWords) {
		if (line.endsWith(endWord)) {
			spaceThenEndWord = ' ' + endWord
			if (!line.endsWith(spaceThenEndWord)) {
				return line.slice(0, line.length - endWord.length) + spaceThenEndWord
			}
		}
	}
	return line
}

function getMultiplied2By3Matrix(matrixA, matrixB) {
	// a c e		0 2 4
	// b d f		1 3 5
	// 0 0 1		    +
	// row by column into row, colum
	// [0 2 4] x [0 1  ] = '0,0 2,1' > a > 0
	// [1 3 5] x [0 1  ] = '1,0 3,1' > b > 1
	// [0 2 4] x [2 3  ] = '0,2 2,3' > c > 2
	// [1 3 5] x [2 3  ] = '1,2 3,3' > d > 3
	// [0 2 4] x [4 5 +] = '0,4 2,5 4,' > e > 4
	// [1 3 5] x [4 5 +] = '1,4 3,5 5,' > f > 5
	a = matrixA[0] * matrixB[0] + matrixA[2] * matrixB[1]
	b = matrixA[1] * matrixB[0] + matrixA[3] * matrixB[1]
	c = matrixA[0] * matrixB[2] + matrixA[2] * matrixB[3]
	d = matrixA[1] * matrixB[2] + matrixA[3] * matrixB[3]
	e = matrixA[0] * matrixB[4] + matrixA[2] * matrixB[5] + matrixA[4]
	f = matrixA[1] * matrixB[4] + matrixA[3] * matrixB[5] + matrixA[5]
	return [a, b, c, d, e, f]
}

function getPolygonBoundingBox(attributeMap, matrix) {
	var boundingBox = [Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]
	var points = getPolygonPoints(attributeMap)
	for (point of points) {
		transformPoint(point, matrix)
		boundingBox[0] = Math.min(boundingBox[0], point[0])
		boundingBox[1] = Math.min(boundingBox[1], point[1])
		boundingBox[2] = Math.max(boundingBox[2], point[0])
		boundingBox[3] = Math.max(boundingBox[3], point[1])
	}
	return boundingBox
}

function getPolygonPoints(attributeMap) {
	if (!attributeMap.has('points')) {
		return []
	}
	lastPoint = [0.0, 0.0]
	points = []
	pointWords = attributeMap.get('points').replace(/,/g, ' ').split(' ').filter(lengthCheck)
	for (pointIndex = 0; pointIndex < pointWords.length; pointIndex += 2) {
		pointX = pointWords[pointIndex]
		if (pointX == '~') {
			pointX = lastPoint[0]
		}
		else {
			pointX = parseFloat(pointX)
		}
		yIndex = pointIndex + 1
		if (yIndex < pointWords.length) {
			pointY = pointWords[yIndex]
			if (pointY == '~') {
				pointY = lastPoint[1]
			}
			else {
				pointY = parseFloat(pointY)
			}
			point = [pointX, pointY]
			points.push(point)
			lastPoint = point
		}
	}
	return points
}

function getStatement(line) {
	var attributeMap = new Map()
	var nestingIncrement = 0
	var strippedWords = getStrippedWords(line)
	var lastIndex = strippedWords.length - 1
	var tag = null
	if (strippedWords.length > 0) {
		firstWord = strippedWords[0]
		if (firstWord.startsWith('</') || firstWord == ']' || firstWord == '}') {
			nestingIncrement = -1
		}
		else {
			if (firstWord.startsWith('<')) {
				firstWord = firstWord.slice(1)
			}
			if (firstWord.length > 0) {
				tag = getCapitalizedKey(firstWord)
			}
		}
		if (strippedWords.length > 1) {
			var lastWord = strippedWords[lastIndex]
			if (lastWord == '>' || lastWord == '[' || lastWord == '{') {
				nestingIncrement = 1
			}
			if (lastWord.endsWith('>') || lastWord == '[' || lastWord == '{') {
				lastIndex -= 1
			}
		}
	}
	var key = null
	var values = null
	// length = 6
	// last = 4
	// 0 1 2 3 4 5
	// m k = v v e
	for (wordIndex = 2; wordIndex < lastIndex + 1; wordIndex++) {
		var word = strippedWords[wordIndex]
		if (word == '=') {
			if (key != null) {
				attributeMap.set(key, values.slice(0, -1).join(' '))
			}
			key = strippedWords[wordIndex - 1]
			keyStrings = key.split('.')
			if (keyStrings.length == 2) {
				keyStrings[0] = getCapitalizedKey(keyStrings[0])
				keyStrings[1] = getCapitalizedKey(keyStrings[1])
				key = keyStrings.join('.')
			}
			values = []
		}
		else {
			if (values != null) {
				values.push(word)
			}
		}
	}
	if (key != null) {
		attributeMap.set(key, values.join(' '))
	}
	var statement = {
	attributeMap:attributeMap,
	children:[],
	nestingIncrement:nestingIncrement,
	openingStatement:null,
	parent:null,
	tag:tag}
	return statement
}

function getStrippedWords(line) {
	var quoteSymbols = ['"', '\'']
	var searchIndexes = [-1,-1]
	var start = 0
	var strippedWords = []
	for (whileIndex = 0; whileIndex < 987654; whileIndex++) {
		for (quoteIndex = quoteSymbols.length -1; quoteIndex > -1; quoteIndex--) {
			searchIndex = line.indexOf(quoteSymbols[quoteIndex], start)
			if (searchIndex < 0) {
				searchIndexes.splice(quoteIndex, 1)
				quoteSymbols.splice(quoteIndex, 1)
			}
			else {
				searchIndexes[quoteIndex] = searchIndex
			}
		}
		if (quoteSymbols.length == 0) {
			addSliceToWords(line.slice(start), strippedWords)
			return strippedWords
		}
		firstIndex = searchIndexes[0]
		quoteSymbol = quoteSymbols[0]
		if (searchIndexes[1] < firstIndex) {
			firstIndex = searchIndexes[1]
			quoteSymbol = quoteSymbols[1]
		}
		end = line.indexOf(quoteSymbol, firstIndex + 1)
		if (end < 0) {
			addSliceToWords(line.slice(start), strippedWords)
			return strippedWords
		}
		addSliceToWords(line.slice(start, firstIndex), strippedWords)
		start = end + 1
		strippedWords.push(line.slice(firstIndex + 1, end))
	}
}

function getXYSubtraction(xyA, xyB) {
	return [xyA[0] - xyB[0], xyA[1] - xyB[1]]
}

function group(family, statement) {
	var attributeMap = statement.attributeMap
	var height = -Number.MAX_VALUE
	var nesting = 0
	var width = -Number.MAX_VALUE
	var border = 0
	for (child of statement.children) {
		var points = getPolygonPoints(child.attributeMap)
		for (point of points) {
			height = Math.max(height, point[1])
			width = Math.max(width, point[0])
		}
	}
	if (attributeMap.has('transform')) {
		var transform = attributeMap.get('transform')
		var entry = getBracketedEntry(transform)
		if (entry[0] == 'translate') {
			commaSeparated = entry[1].split(',')
			var xString = commaSeparated[0]
			xString = xString.replace('width', (width + 1).toFixed(0))
			var groupStorage = null
			if (family.storageMap.has('group')) {
				groupStorage = family.storageMap.get('group')
				xString = xString.replace('border', groupStorage.border.toString())
				xString = getIDReplaced(xString, groupStorage.border + groupStorage.border, groupStorage.widthMap)
			}
			var addition = getAddition(xString)
			if (groupStorage == null) {
				border = addition
			}
			xString = addition.toFixed(0)
			if (commaSeparated.length > 1) {
				yString = commaSeparated[1].replace('height', (height + 1).toFixed(0))
				if (groupStorage != null) {
					yString = getIDReplaced(yString, groupStorage.border, groupStorage.heightMap)
				}
				xString = xString + ',' + getAddition(yString).toFixed(0)
			}
			attributeMap.set('transform', 'translate(' + xString + ')')
		}
	}
	groupStorage = null
	if (family.storageMap.has('group')) {
		groupStorage = family.storageMap.get('group')
	}
	else {
		groupStorage = {border:border, heightMap:new Map(), widthMap:new Map()}
		family.storageMap.set('group', groupStorage)
	}
	if (attributeMap.has('id')) {
		var id = attributeMap.get('id')
		groupStorage.heightMap.set(id, height)
		groupStorage.widthMap.set(id, width)
	}
	statement.tag = 'g'
}

function lengthCheck(word) {
	return word.length > 0
}

function matrix(floats) {
	return floats
}

function mirror(family, statement) {
	var attributeMap = statement.attributeMap
	points = getPolygonPoints(attributeMap)
	angle = getFloatValue(0.0, 'angle', statement) * Math.PI / 180.0
	x = getFloatValue(0.0, 'x', statement)
	y = getFloatValue(0.0, 'y', statement)
	mirrorFromX = x + x
	for (pointIndex = points.length - 1; pointIndex > -1; pointIndex--) {
		point = points[pointIndex]
		mirrorPoint = [mirrorFromX - point[0], point[1]]
		points.push(mirrorPoint)
	}
	deleteKeys('angle x y', attributeMap)
	attributeMap.set('points', points.join(' '))
	statement.tag = 'polygon'
}

function outline(family, statement) {
	var attributeMap = statement.attributeMap
	if (attributeMap.has('flip')) {
		flipScale = [1.0, 1.0]
		floats = getFloats(attributeMap.get('flip'))
		if (floats.length > 0) {
			flipScale = [floats[0], floats[0]]
			if (floats.length > 1) {
				flipScale[1] = floats[1]
			}
		}
		flipScale[1] = -flipScale[1]
		scaleString = 'scale(' + flipScale[0] + ',' + flipScale[1] + ')'
		attributeMap.set('transform', scaleString)
	}
	var styleMap = new Map([
		['fill', 'none'],
		['stroke', 'rgb(0,0,0)'],
		['stroke-width', '1']])
	if (attributeMap.has('style')) {
		styles = attributeMap.get('style').replace(/ /g, '').split(';')
		for (style of styles) {
			var entry = style.split(':')
			styleMap.set(entry[0], entry[1])
		}
	}
	styles = []
	for (entry of styleMap) {
		styles.push(entry[0] + ':' + entry[1])
	}
	attributeMap.set('style', styles.join(';'))
	titleStrings = []
	if (attributeMap.has('project')) {
		titleStrings.push(attributeMap.get('project'))
	}
	if (attributeMap.has('id')) {
		titleStrings.push(attributeMap.get('id'))
	}
	if (attributeMap.has('date')) {
		titleStrings.push(attributeMap.get('date'))
	}
	titleStrings.push('Wordscape')
	document.title = titleStrings.join(' - ')
	attributeMap.delete('flip')
	statement.tag = 'g'
}

function rotate(floats) {
	if (floats.length == 0) {
		return [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	}
	rotation = floats[0] * Math.PI / 180.0
	cosAngle = Math.cos(rotation)
	sinAngle = Math.sin(rotation)
//	a c e		0 2 4
//	b d f		1 3 5
//	0 0 1		    +
//	cos -sin
//	sin cos
	var latestMatrix = [cosAngle, sinAngle, -sinAngle, cosAngle, 0.0, 0.0]
	if (floats.length < 2) {
		return latestMatrix
	}
	x = 0.0
	y = 0.0
	if (floats.length > 1) {
		x = floats[1]
	}
	if (floats.length > 2) {
		y = floats[2]
	}
	latestMatrix = getMultiplied2By3Matrix(latestMatrix, [1.0, 0.0, 0.0, 1.0, -x, -y])
	return getMultiplied2By3Matrix([1.0, 0.0, 0.0, 1.0, x, y], latestMatrix)
}

function scale(floats) {
	var latestMatrix = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	if (floats.length == 0) {
		return latestMatrix
	}
	latestMatrix[0] = floats[0]
	if (floats.length > 1) {
		latestMatrix[3] = floats[1]
	}
	else {
		latestMatrix[3] = latestMatrix[0]
	}
	return latestMatrix
}

function setMatrix(statement, matrixTags, matrix, nesting) {
	if (matrixTags.length > 0) {
		if (nesting < matrixTags[matrixTags.length - 1].nesting) {
			matrixTags.pop()
			return
		}
	}
	if (statement.tag == null) {
		return
	}
	if (!statement.attributeMap.has('transform')) {
		return
	}
	entry = getBracketedEntry(statement.attributeMap.get('transform'))
	if (entry.length < 2) {
		return
	}
	transformType = entry[0]
	if (!gTransformMap.has(transformType)) {
		return
	}
	var latestMatrix = gTransformMap.get(transformType)(getFloats(entry[1]))
	var matrixTag = {matrix:latestMatrix, nesting:nesting, tag:statement.tag}
	matrixTags.push(matrixTag)
	if (matrixTags.length > 1) {
		for (index = matrixTags.length - 2; index > -1; index--) {
			latestMatrix = getMultiplied2By3Matrix(matrixTags[index].matrix, latestMatrix)
		}
	}
	for (matrixIndex = 0; matrixIndex < 6; matrixIndex++) {
		matrix[matrixIndex] = latestMatrix[matrixIndex]
	}
}

function setNumberOfRows(id, lines) {
	var numberOfRows = 1
	var oneOverColumns = 1.0 / document.getElementById(id).cols
	for (line of lines) {
		numberOfRows += Math.ceil(oneOverColumns * (line.length + 1))
	}
	document.getElementById(id).rows = numberOfRows
}

function setWordArea() {
	var query = document.URL
	indexOfQuestionMark = query.indexOf('?')
	if (indexOfQuestionMark < 0) {
		query = ''
	}
	else {
		query = query.slice(indexOfQuestionMark + 1)
	}
	query = query.replace(gEscapeExpression, function(find) {return gEscapeTable[find]})
	indexOfNewline = query.indexOf('\n')
	if (indexOfNewline < 0) {
		query = query.replace(/></g, '>\n<')
	}
	document.getElementById('wordArea').value = query
}

function skewX(floats) {
	if (floats.length == 0) {
		return [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	}
	var rotation = floats[0] * Math.PI / 180.0
//	a c e		0 2 4
//	b d f		1 3 5
//	0 0 1		    +
//	1 tan
//	0 1
	return [1.0, 0.0, Math.tan(rotation), 1.0, 0.0, 0.0]
}

function skewY(floats) {
	if (floats.length == 0) {
		return [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	}
	var rotation = floats[0] * Math.PI / 180.0
//	a c e		0 2 4
//	b d f		1 3 5
//	0 0 1		    +
//	1 0
//	tan 1
	return [1.0, Math.tan(rotation), 0.0, 1.0, 0.0, 0.0]
}

function transformPoint(point, matrix) {
	originalX = point[0]
//	a c e		0 2 4
//	b d f		1 3 5
	point[0] = point[0] * matrix[0] + point[1] * matrix[2] + matrix[4]
	point[1] = originalX * matrix[1] + point[1] * matrix[3] + matrix[5]
}

function translate(floats) {
	var latestMatrix = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	if (floats.length == 0) {
		return latestMatrix
	}
	latestMatrix[4] = floats[0]
	if (floats.length > 1) {
		latestMatrix[5] = floats[1]
	}
	return latestMatrix
}

function update() {
	var svgString = updateSVGArea()
	document.getElementById('paragraphText').innerHTML = svgString
	var wordString = document.getElementById('wordArea').value
	document.getElementById('queryLink').href = '?' + wordString.replace(/\n/g, '%0A')
	gNumberOfUpdates += 1
	if (gNumberOfUpdates > 0) {
		document.getElementById('queryLink').innerHTML = 'Link Update ' + gNumberOfUpdates.toString()
	}
}

function updateSVGArea() {
	var svgStatement = null
	var family = {idMap:new Map(), parents:[], statements:[], storageMap:new Map()}
	var wordString = document.getElementById('wordArea').value
	wordString = wordString.replace(gBracketExpression, function(find) {return gBracketTable[find]})
	var splitWord = '\n'
	if (wordString.indexOf('\r\n') > -1) {
		splitWord = '\r\n'
	}
	var lines = wordString.split(splitWord)
	for (line of lines) {
		var statement = getStatement(line)
		if (family.parents.length > 0) {
			statement.parent = family.parents[family.parents.length - 1]
			statement.parent.children.push(statement)
			if (statement.tag != null) {
				var idString = statement.tag
				if (statement.attributeMap.has('id')) {
					idString = statement.attributeMap.get('id')
				}
				else {
					subIdentifiers = []
					var keys = 'cx cy x y r'.split(' ')
					for (key of keys) {
						if (statement.attributeMap.has(key)) {
							subIdentifiers.push(key + statement.attributeMap.get(key))
						}
					}
					if (statement.attributeMap.has('points')) {
						pointStrings = statement.attributeMap.get('points').replace(/,/g, ' ').split(' ').filter(lengthCheck).slice(2, 4)
						subIdentifiers.push(pointStrings.join('-'))
					}
					var parentMap = statement.parent.attributeMap
					if (parentMap.has('id')) {
						idString += '-' + parentMap.get('id')
					}
					subIdentifiers.reverse()
					var suffix = ''
					for (whileIndex = 1; whileIndex < 98765; whileIndex++) {
						check = idString + suffix
						if (family.idMap.has(check)) {
							if (subIdentifiers.length > 0) {
								idString = idString + '-' + subIdentifiers[subIdentifiers.length - 1]
								subIdentifiers.pop()
							}
							else {
								suffix = '-' + whileIndex.toString()
							}
						}
						else {
							idString = check
							whileIndex += 987654321
						}
					}
					statement.attributeMap.set('id', idString)
				}
				family.idMap.set(idString, statement)
			}
		}
		if (statement.nestingIncrement == 1) {
			family.parents.push(statement)
		}
		else {
			if (statement.nestingIncrement == -1) {
				statement.openingStatement = family.parents[family.parents.length - 1]
				family.parents.pop()
			}
		}
		if (gTagMap.has(statement.tag)) {
			gTagMap.get(statement.tag)(family, statement)
		}
		if (svgStatement == null) {
			if (statement.tag == 'svg') {
				svgStatement = statement
			}
		}
		family.statements.push(statement)
	}
	for (statement of family.statements) {
		if (gFollowingMap.has(statement.tag)) {
			gFollowingMap.get(statement.tag)(family, statement)
		}
	}
	var height = 0.0
	var lineThickness = 10
	var width = 0.0
	var matrix = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
	var matrixTags = []
	var nesting = 0
	for (statement of family.statements) {
		nesting += statement.nestingIncrement
		setMatrix(statement, matrixTags, matrix, nesting)
		if (statement.tag == 'polygon') {
			boundingBox = getPolygonBoundingBox(statement.attributeMap, matrix)
			height = Math.max(height, boundingBox[3])
			width = Math.max(width, boundingBox[2])
		}
	}
	height += lineThickness
	width += lineThickness
	if (svgStatement == null) {
		svgStatement = getStatement('<svg >')
		family.statements.splice(0, 0, svgStatement)
		family.statements.push(getStatement('</svg>'))
	}
	if (!svgStatement.attributeMap.has('height')) {
		svgStatement.attributeMap.set('height', height.toFixed())
	}
	if (!svgStatement.attributeMap.has('width')) {
		svgStatement.attributeMap.set('width', width.toFixed())
	}
	if (!svgStatement.attributeMap.has('xmlns')) {
		svgStatement.attributeMap.set('xmlns', 'http://www.w3.org/2000/svg')
	}
	var svgLines = []
	for (statement of family.statements) {
		svgLines.push(getLineByStatement(statement))
	}
	joinWord = '\n'
	if (navigator.appVersion.indexOf("Win") > -1) {
		joinWord = '\r\n'
	}
	var svgString = svgLines.join(joinWord)
	setNumberOfRows('wordArea', lines)
	setNumberOfRows('svgArea', svgLines)
	document.getElementById('svgArea').value = svgString
	return svgString
}

function verticalHole(family, statement) {
	var attributeMap = statement.attributeMap
	angle = getFloatValue(40.0, 'angle', statement) * Math.PI / 180.0
	cx = getFloatValue(0.0, 'cx', statement)
	cy = getFloatValue(0.0, 'cy', statement)
	radius = getFloatValue(1.0, 'r', statement)
	sagAngle = getFloatValue(15.0, 'sagAngle', statement) * Math.PI / 180.0
	sides = getFloatValue(24.0, 'sides', statement)
	points = []
	beginAngle = Math.PI / 2.0 - angle
	endAngle = 1.5 * Math.PI + angle
	maximumIncrement = 2.0 * Math.PI / sides
	deltaAngle = endAngle - beginAngle
	arcSides = Math.ceil(deltaAngle / maximumIncrement - 0.001 * angle)
	angleIncrement = deltaAngle / arcSides
	halfAngleIncrement = 0.5 * angleIncrement
	beginAngle -= halfAngleIncrement
	endAngle += halfAngleIncrement + 0.001 * angle
	outerRadius = radius / Math.cos(0.5 * angleIncrement)
	for (pointAngle = beginAngle; pointAngle < endAngle; pointAngle += angleIncrement) {
		x = cx + Math.sin(pointAngle) * outerRadius
		y = cy + Math.cos(pointAngle) * outerRadius
		points.push([x, y])
	}
	topY = cy + radius
	deltaBegin = getXYSubtraction(points[0], points[1])
	sagRunOverRise = Math.cos(sagAngle) / Math.sin(sagAngle)
	segmentRunOverRise = deltaBegin[0] / deltaBegin[1]
	approachRunOverRise = sagRunOverRise - segmentRunOverRise
	topMinusSegment = topY - points[0][1]
	topX = topMinusSegment * segmentRunOverRise + points[0][0]
	aboveMinusTopY = (topX - cx) / approachRunOverRise
	sagDeltaX = aboveMinusTopY * sagRunOverRise
	aboveY = topY + aboveMinusTopY
	points[0] = [cx + sagDeltaX, aboveY]
	points[points.length - 1] = [cx - sagDeltaX, aboveY]
	for (pointIndex = 0; pointIndex < points.length; pointIndex++) {
		point = points[pointIndex]
		points[pointIndex] = [point[0].toFixed(3), point[1].toFixed(3)]
	}
	deleteKeys('angle cx cy r sagAngle sides', attributeMap)
	attributeMap.set('points', points.join(' '))
	statement.tag = 'polygon'
}

var gCapitalizationMap = new Map()
var gFollowingMap = getFunctionMapCapitalize(['group', group])
var gTagMap = getFunctionMapCapitalize(['mirror', mirror, 'outline', outline, 'verticalHole', verticalHole])
var gTransformMap = new Map([
	['matrix', matrix],
	['rotate', rotate],
	['scale', scale],
	['skewX', skewX],
	['skewY', skewY],
	['translate', translate]])
addToCapitalizationMap('sagAngle')
setWordArea()
update()
</script>
</body>
</html>
