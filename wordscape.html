<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Wordscape</title>
</head>
<body>
<table>
<tr>
<th><p id="paragraphText"></p></th><th><canvas id="viewerCanvas" width="400" height="300" style="border:1px solid black"></canvas></th>
</tr>
</table>
<table style="width:50%">
<tr>
<td><button type="button" onclick="update()">Update</button><td>
<td><select hidden="true" id="querySelect" onchange ="querySelectChanged()"></select><td>
<td><button hidden="false" id="newButton" onclick="windowNew()" type="button">New</button><td>
<td><select hidden="true" id="viewSelect" onchange ="viewSelectChanged()"></select><td>
</tr>
<tr>
<td><button hidden="true" type="button"></button><td>
<td><select hidden="true"></select><td>
<td><a hidden="true" id="queryLink" href="index.html">Original Link</a><td>
<td><select hidden="true" id="typeSelect" onchange ="typeSelectChanged()"></select></td>
</tr>
</table>
<textarea id="wordArea" rows="20" cols="120"></textarea><br>
<br>
<h3>SVG</h3>
<textarea id="svgArea" rows="40" cols="120"></textarea><br>
<br>
<h3>Mesh</h3>
<textarea id="meshArea" rows="10" cols="120"></textarea><br>
<br>
<script src="alteration.js"></script>
<script src="construction.js"></script>
<script src="codec.js"></script>
<script src="help.js"></script>
<script src="generator2d.js"></script>
<script src="generator3d.js"></script>
<script src="maparray.js"></script>
<script src="matrix.js"></script>
<script src="meta.js"></script>
<script src="parsenumber.js"></script>
<script src="parseword.js"></script>
<script src="polygon.js"></script>
<script src="polyhedron.js"></script>
<script src="statement.js"></script>
<script src="viewer.js"></script>
<script>
//License = GNU Affero General Public License http://www.gnu.org/licenses/agpl.html
//
//subtraction xyz
//change exterior to voxel and pixel
//layers=[{transform, [polygon]}], closed, plane
//test basis, transform in pillar
//verticalHole should be widdershins, all widdershins should be reversed when making a mesh when on outside
//analyze volume and surface area
//view transform3D
//hidden lines
//sculpture mosaics=[{transform,[surfacets]}], closed surfacet={indegons, bottom, top} indegon can be indexed x,y,z;index,id,polygonIndex
//slice svg=id layerThickness=0.6 viewer=none/basic layerHeights=none/[]
//test transform3D
//combination id=a+b-c#d!#e*f/g ** h on vertex
//add circles and rect to bounding box
//check backslash quote in quoteSeparated
//codeStyle indentation start increment type groupDelimeter
//wireframe/solid choice, instructions, 3D direction display, settings, wait, animation, separate polygons option
//set descendants depth with statement
//extrusion sort closest before splicing if they are both on same edge arrowindexsetmap only needed with thin shapes
//transform3D extrusionPath(heights, polyline, polygon, polyplane)
//maybe outputTriangleMesh stl=id, nextID..
//mirror line y and vector, polyrect
//setLocal, setGlobal, if switch case else, for
//outset, shell, tile, venturi, helix, unlimited, terrain, road
//gear/wheel, wing, propeller, pipe/pail, pulley/cable, chair/shelf, gores?, lattice?, haxagonal extrusion
//humanoid, quadruped, door/window, lamp/chandelier, gemstone, press, arch, column, pontoon, box, shoe/hat, ribs/umbrella, house
//wrench/screwdriver, alteration machine
//document.getElementById("wordArea").onkeydown = function(evt) {(evt) ? evt : window.event if (evt.keyCode == 13) {alert("e");}}
//textArea.value.slice(0, textArea.selectionStart).split('\n').length - 1
//deprecated ~ for replace, [ for group ending, [] for id, flip
/*
lastKeyDownCode = null
areaKeyDown = function(evt) {
    (evt) ? evt : window.event
    lastKeyDownCode = evt.keyCode
}

areaInput = function(evt) {
    if (lastKeyDownCode == 13) {
    lines=wordArea.value.split("\n")
    lines[getLineNumber(wordArea)] = '    '
   wordArea.value = lines.join('\n')
    }
}
wordArea.onkeydown = areaKeyDown
wordArea.oninput = areaInput
*/

function addToMeshArea(meshString) {
	if (meshString == null) {
		return
	}
	var meshArea = document.getElementById('meshArea')
	if (meshArea.value == '') {
		meshArea.value = meshString
		return
	}
	meshArea.value = meshArea.value + '\n' + meshString
}

function analyzeOutputMesh(attributeMap, meshGenerator, registry, statement) {
	var attributeID = attributeMap.get('id')
	registry.objectMap.set(attributeID, meshGenerator)
	if (attributeMap.has('outputTriangleMesh')) {
		if (attributeMap.get('outputTriangleMesh') == 'stl') {
			addToMeshArea(getTriangleMeshString('stl', attributeID, getTriangleMesh(meshGenerator.getMesh())))
		}
	}
	if (attributeMap.has('analysis')) {
		var meshAnaysisMap = null
		if (attributeMap.get('analysis')[0] == 't') {
			meshAnaysisMap = getMeshAnalysis(getTriangleMesh(meshGenerator.getMesh()))
		}
		else {
			if (attributeMap.get('analysis')[0] == 'p') {
				meshAnaysisMap = getMeshAnalysis(meshGenerator.getMesh())
			}
		}
		if (meshAnaysisMap != null) {
			var analysisStatement = getStatement('analysis')
			analysisStatement.attributeMap = meshAnaysisMap
			analysisStatement.attributeMap.set('id', attributeID + '_analysis')
			analysisStatement.parent = statement
			statement.children.splice(-1, 0, analysisStatement)
		}
	}
	if (attributeMap.has('view')) {
		meshViewer.addMesh(attributeID, null)
	}
}

function getGroupBoundingBox(caller, statement) {
	var boundingBox = null
	var descendants = []
	addToDescendantsInsideFirst(descendants, statement)
	for (var child of descendants) {
		boundingBox = widenStatementBoundingBox(boundingBox, caller, child)
	}
	return boundingBox
}

function getInsets(statement) {
	var insets = getPointsByTag('insets', statement, 'polygon')
	if (insets == null) {
		return [[1.0]]
	}
	return insets
}

function getMeshesByChildren(children, registry) {
	var meshes = []
	for (var child of children) {
		var attributeID = child.attributeMap.get('id')
		if (registry.objectMap.has(attributeID)) {
			meshes.push(registry.objectMap.get(attributeID).getMesh())
		}
	}
	return meshes
}

function getPolygonPoints(statement) {
	return getPointsByTag('points', statement, 'polygon')
}

function getPolygonsByChildren(children) {
	var polygons = []
	for (var child of children) {
		var points = getPolygonPoints(child)
		if (points != null) {
			polygons.push(points)
		}
	}
	return polygons
}

function getStratas(attributeMap) {
	var stratas = getFloatLists(attributeMap, 'stratas')
	if (stratas == null) {
		return [[]]
	}
	if (stratas.length == 0) {
		stratas.push([])
	}
	return stratas
}

function getTransform2DsByChildren(children) {
	var transform2DsByChildren = null
	for (var child of children) {
		var transform2Ds = getPointsByTag('transform2Ds', child, 'derive2D')
		if (transform2Ds != null) {
			if (transform2DsByChildren == null) {
				transform2DsByChildren = transform2Ds
			}
			else {
				pushArray(transform2DsByChildren, transform2Ds)
			}
		}
	}
	return transform2DsByChildren
}

function getWorkMesh(attributeMap, registry) {
	if (!attributeMap.has('work')) {
		return null
	}
	var work = attributeMap.get('work')
	if (!registry.objectMap.has(work)) {
		return null
	}
	var workGenerator = registry.objectMap.get(work)
	if (workGenerator == null) {
		return null
	}
	var workMesh = workGenerator.getMesh()
	if (attributeMap.has('copy')) {
		if (attributeMap.get('copy')[0] == 't') {
			workMesh = getMeshCopy(workMesh)
		}
	}
	return workMesh
}

function update() {
	document.getElementById('meshArea').value = ''
	var svgString = updateSVGArea()
	document.getElementById('paragraphText').innerHTML = svgString
	setQueryStorage('newButton', 'querySelect', document.getElementById('wordArea').value)
}

function updateSVGArea() {
	var lines = getBracketReplacedLines('wordArea')
	var registry = {idMap:new Map(), objectMap:new Map(), storageMap:new Map()}
	meshViewer.setID('viewerCanvas', registry.objectMap, 'typeSelect', 'viewSelect')
	var svgStatement = getDocumentRoot(lines, 'svg')
	var descendants = [svgStatement]
	addToDescendantsOutsideFirst(descendants, svgStatement)
	for (var statement of descendants) {
		if (statement.tag != null) {
			registry.idMap.set(getStatementID(registry, statement), statement)
		}
	}
	createDefault(svgStatement, registry)
	processDescendantsByTagMap(registry, svgStatement, gTagMap)
	var descendants = [svgStatement]
	addToDescendantsOutsideFirst(descendants, svgStatement)
	var lineThickness = 10
	var boundingBox = getGroupBoundingBox(null, svgStatement)
	var height = lineThickness
	var padding = 5
	var width = lineThickness
	if (boundingBox != null) {
		height += boundingBox[1][1]
		width += boundingBox[1][0] + lineThickness
	}
	if (registry.storageMap.has('group')) {
		width += registry.storageMap.get('group').scaledBorder
	}
	height = Math.max(height, 300)
	width = Math.max(width, 300)
	if (!svgStatement.attributeMap.has('height')) {
		svgStatement.attributeMap.set('height', height.toFixed())
	}
	if (!svgStatement.attributeMap.has('style')) {
		svgStatement.attributeMap.set('style', 'border:1px solid black;padding:' + padding.toString() + 'px')
	}
	if (!svgStatement.attributeMap.has('width')) {
		svgStatement.attributeMap.set('width', width.toFixed())
	}
	if (!svgStatement.attributeMap.has('xmlns')) {
		svgStatement.attributeMap.set('xmlns', 'http://www.w3.org/2000/svg')
	}
	var svgLines = getPassthroughLines(descendants, 'svg')
	var joinWord = getJoinWord()
	var svgString = svgLines.join(joinWord)
	setNumberOfRows('wordArea', lines)
	setNumberOfRows('svgArea', svgLines)
	document.getElementById('svgArea').value = svgString
	meshViewer.start(height + padding + padding)
	return svgString
}

var gTagMap = new Map()
setProcessorMap(gAlterationProcessors, gTagMap)
setProcessorMap(gConstructionProcessors, gTagMap)
setProcessorMap(gGenerator2DProcessors, gTagMap)
setProcessorMap(gGenerator3DProcessors, gTagMap)
setProcessorMap(gMetaProcessors, gTagMap)

setTextArea('wordArea')
update()
</script>
</body>
</html>
